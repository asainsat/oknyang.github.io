---
title: "clean architecture 1~2"
date: 2020-01-02
categories: architecture
---

## 1. 설계와 아키텍쳐란?
설계와 아키텍쳐느 개별로는 존재할 수 없고, 실제로 이 둘을 구분짓는 경계는 뚜렷하지 않다. 고수준에서 저수준으로 향하는 의사결정의 연속성만 있을 뿐이다.

### 좋은 소프트웨어 설계의 목표
소프트웨어 아키텍처의 목표는 필요한 시스템을 만들고 유지보수하는 데 투입되는 인력을 최소화하는 데 있다.

### 결론
소프트웨어 아키텍처를 심각학 고려할 수 있으려면 좋은 소프트웨어 아키텍척 무엇읹 이해해야 한다. 비용은 최소화하고 생산성은 최대화 할 수 있는 설계와 아키텍처를 가진 시스템을 만들려면, 이러한 결과로 이끌어줄 시스템 아키텍처가 가진 속성을 알고 있어야 한다.

## 2. 두 가지 가치에 대한 이야기
모든 소프트웨어 시스템은 이해관계자에게 서로 다른 두 가지 가치를 제공해야 하는데, **행위(behavior)** 와 **구조(structure)** 가 바로 그것이다.

### 행위
소프트웨어의 첫번쨰 가치는 바로 행위(behavior)다. 많은 프로그래머가 요구사항을 기계에 구현하고 버그를 수정하는 일이 자신의 직업이라고 믿는다. 슬픈 일이지만 그들은 틀렸다.

### 아키텍처
소프트웨어는 '부드러운'과 '제품'의 합성어다. 소프트웨어는 '부드러움을 지니도록' 만들어졌다. 소프트웨어를 만든 이유는 기계의 행위를 쉽게 변경할 수 있도록 하기 위해서다.  
소프트웨어가 가진 본연의 목적을 추구하려면 소프트웨어는 반드시 '부드러워'야 한다. 다시 말해 **변경하기 쉬워야 한다**. 변경사항을 적용하는 데 드는 어려움은 변경되는 범위(scope)에 비례해야 하며, 변경사항의 형태(shape)와는 관련이 없어야 한다.  
**아키텍처는 형태에 독립적이어야 하고, 그럴수록 더 실용적이다.**

### 더 높은 가치
기능과 아키텍처 중 기능보다는 아키텍처가 중요하다. 유연한 아키텍처는 변경이 쉽고 유지보수에도 유리하다.

### 아이젠하워 매트릭스
```text
내겐 두 가지 유형의 문제가 있습니다. 하나는 긴급하며, 다른 하나는 중요합니다. 긴급한 문제는 중요하지 않으며, 중요한 문제는 절대 긴급하지 않습니다.
- 1954년 노스웨스턴 대학교 강연에서 드와이트 D. 아이젠하워 -
```

이 격언은 긴급한 문제가 아주 중요한 문제일 경우는 드물고, 중요한 문제가 몹시 긴급한 경우는 거의 없다는 말로, 소프트웨어에도 대입해 볼 수 있다.  
행위는 긴급하지만 매번 높은 중요도를 가지는 것은 아니다.  
아키텍처는 중요하지만 즉각적인 긴급성을 필요로 하는 경우는 절대 없다.  

아이젠하우 매트릭스 우선순위를 매겨보면 다음과 같다.
1. 긴급하고 중요한
2. 긴급하지는 않지만 중요한
3. 긴급하지만 중요하지는 않은
4. 긴급하지도 중요하지도 않은

아키텍처, 즉 중요한 일은 이 항목의 가장 높은 두 우선순위를 차지하는 반면, 행위는 첫 번째와 세 번째에 위치한다는 점을 주목하자.  
기능의 긴급성이 아니 아키텍처의 중요성을 설득하는 일은 소프트웨어 개발팀이 마땅히 책임져야 한다.

### 아키텍처를 위해 투쟁하라
아키텍처가 후순위가 되면 시스템을 개발하는 비용이 더 많이 들고, 일부 또는 전체 시스템에 변경을 가하는 일이 현실적으로 불가능해진다. 이러한 상황이 발생하도록 용납했다면, 이는 결국 소프트웨어 개발팀이 옳다고 믿는 가치를 위해 충분히 투쟁하지 않았다는 뜻이다.

## 3. 패러다임 개요
### 구조적 프로그래밍
구조적 프로그래밍은 제어흐름으 직접적인 전환에 대해 규칙을 부과한다.

### 객체 지향 프로그래밍
객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 대해 규칙을 부과한다.

### 함수형 프로그래밍
함수형 프로그래밍은 할당문에 대해 규칙을 부과한다.

### 생각할 거리
각 패러다임은 프로그래머에게서 권한을 박탈한다. 즉, 패러다임은 무엇을 해야 할지를 말하기보다는 무엇을 해서는 안 되는지를 말해준다.

### 결론
세 가지 패러다임과 아키텍처의 세 가지 큰 관심사(함수, 컴포넌트 분리, 데이터 관리)가 어떻게 서로 연관되는지에 주목하자.
- 아키텍처 경계를 넘나들기 위한 메커니즘으로 다형성을 이용
- 함수형 프로그래밍을 이용하여 데이터의 위치와 접근 방법에 대해 규칙을 부과
- 모듈의 기반 알고리즘으로 구조적 프로그래밍을 사용

## 4. 구조적 프로그래밍
에츠허르 비버 데이크스트라가 최초 발견.

### 증명
데이크스트라가 초기에 인식한 문제는 프로그래밍은 어렵고, 프로그래머는 프로그래밍을 잘 하지 못한다는 사실이었다.  
데이크스트라는 증명(proof)이라는 수학적인 원리를 적용하여 이 문제를 해결하고자 했다. 프로그래머는 입증된 구조를 이용하고, 이들 구조를 코드와 결합시키며, 그래서 코드가 올바르다는 사실을 스스로 증명하는 방식을 사용할 수 있다고 믿었다.  
데이크스트라느 이와 관련된 연구를 진행하던 중 goto 문장이 모듈을 더 작은 단위로 재귀적으로 분해하는 과정에 방해가 되는 경우가 있다는 사실을 발견했다. 반면 goto 문장이 if/then/else, do/while 과 같은 분기와 반복이라는 단순한 제어구조에 적합하다는 것을 발견했다.  
그는 이러한 제어 구조는 순차 실행과 결합했을 때 특별하다는 사실을 깨달았다.  
이 발견은 실로 놀라웠다. 즉, 모듈을 증명 가능하게 하는 바로 그 제어 구조가 모든 프로그램을 만들 수 있는 제어 구조의 최소 집합과 동일하다는 사실이었다. 구조적 프로그래밍은 이렇게 탄생했다.  
-> goto 문장은 반드시 제어가 있어야만 효용성이 있다는 것을 발견했다는 말인듯..

### 해로운 성명서
1968년 데이크스트라는 "goto문의 해로움"이라는 제목의 기고를 했고, goto문과 관련된 논쟁은 10년 넘게 지속되었다.  
이 논쟁은 결국 데이크스트라의 승리로 끝났으며, 현재의 우리는 모두 구조적 프로그래머이며, 여기에는 선택의 여지가 없다. 제어흐름을 제약없이 직접 전환할 수 있는 선택권 자체를 언어에서 제공하지 않기 때문이다.

### 기능적 분해
구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해할 수 있게 되었고, 이는 결국 모듈을 기능적으로 분해할 수 있음을 뜻했다.  
이를 토대로 구조적 분석이나 구조적 설계와 같은 기법이 1970년대 후반에서 1980년대에 걸쳐 인기를 끌었다. 이들 기법을 사용하면 프로그래머는 대규모 시스템을 모듈과 컴포넌트로 나눌 수 있고, 더 나아가 모듈과 컴포넌트는 입증할 수 있는 아주 작은 기능들로 세분화할 수 있다.

### 결론
구조적 프로그래밍이 오늘날까지 가치있는 이유는 프로그래밍에서 반증 가능한 단위를 만들어 낼 수 있는 바로 이 능력 때문이다.  
가장 작은 기능에서부터 가장 큰 컴포넌트에 이르기까지 모든 수준에서 소프트웨어는 과학과 같고, 따라서 반증 가능성에 의해 주도된다. 소프트웨어 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록(테스트하기 쉽도록) 만들기 위해 분주히 노력해야 한다.

## 5. 객체 지향 프로그래밍
좋은 아키텍처를 만드는 일은 객체 지향(Object-Orientied, OO) 설계 원칙을 이해학 응용하는 데서 출발한다.  
OO의 본질은 캡슐화, 상속, 다형성의 세 가지 개념을 적절하게 조합한 것이거나, 또는 OO 언어는 최소한 세 가지 요소를 반드시 지원해야 한다.

### 캡슐화?
OO를 정의하는 요소 중 하나로 캡슐화를 언급하는 이유는 데이터와 함수를 쉽고 효과적으로 캡슐화하는 방법을 OO 언어가 제공하기 때문이다. 그리고 이를 통해 데이터와 함수가 응집력 있게 구성된 집단을 서로 구분 짓는 선을 그을 수 있다. 구분선 바깥에서 데이터는 은닉되고, 일부 함수만이 외부에 노출된다. 이 개념들이 실제 OO 언어에서는 각각 클래스의 private 멤버 데이터와 public 멤버 함수로 표현된다.  

C언어에서는 선언과 구현의 분리를 통해 완벽한 캡슐화가 가능했으나, C#, java 등의 언어에서는 기술적인 이유로 헤더와 구현체를 분리하는 방식을 모두 버렸고, 이로 인해 캡슐화는 더욱 심학 훼손되었다. 이들 언어에서는 클래스 선언과 정의를 구분하는 게 아예 불가능하다.  
이 때문에 OOㄱ 강력한 캡슐화에 의존한다는 정의는 받아들이기 힘들다. 실제로 많은 OO 언어가 캡슐화를 거의 강제하지 않는다.  
OO 프로그래밍은 프로그래머가 충분히 올바르게 행동함으로써 캡슐화된 데이터를 우회해서 사용하지 않을 거라는 믿음을 기반으로 한다. 하지만 OO를 제공한다고 주창한 언어들이 실제로는 C언어에서 누렸던 완벽한 캡슐화를 약화시켜 온 것은 틀림없다.

### 상속?
OO 언억 더 나은 캡슐화를 제공하지는 못했지만, 상속만큼은 OO 언어가 확실히 제공했다.  
하지만 상속이란 단순히 어떤 변수와 함수를 하나의 유효 범위로 묶어서 재정의하는 일에 불과하다. 사실상 OO 언어가 있기 훨씬 이전에도 C프로그래머는 언어의 도움 없이 손수 이러한 방식으로 구현할 수 있었다. 하지만 상속을 흉내내는 요령은 있었지만, 사실상 상속만큼 편리한 방식은 절대 아니었다. 게다가 이 기법을 이용해서 다중 상속을 구현하기란 훨씬 더 어려운 일이었다.  
OO 언어가 완전히 새로운 개념을 만들지는 못했지만, 데이터 구조에 가면을 씌우는 일을 상당히 편리한 방식으로 제공했다고는 볼 수 있다.  
간략히 요약하면, 캡슐화에 대해서는 OO에 점수를 줄 수 없고, 상속에 대해서만 0.5점 정도를 부여할 수 있다. 이렇게만 보면 그저 그런 점수다.

### 다형성?






