---
title: "clean architecture 1~2"
date: 2020-01-02
categories: architecture
---

## 1. 설계와 아키텍쳐란?
설계와 아키텍쳐는 개별로는 존재할 수 없고, 실제로 이 둘을 구분짓는 경계는 뚜렷하지 않다. 고수준에서 저수준으로 향하는 의사결정의 연속성만 있을 뿐이다.

### 좋은 소프트웨어 설계의 목표
소프트웨어 아키텍처의 목표는 필요한 시스템을 만들고 유지보수하는 데 투입되는 인력을 최소화하는 데 있다.

### 결론
소프트웨어 아키텍처를 심각학 고려할 수 있으려면 좋은 소프트웨어 아키텍처가 무엇인지 이해해야 한다. 비용은 최소화하고 생산성은 최대화 할 수 있는 설계와 아키텍처를 가진 시스템을 만들려면, 이러한 결과로 이끌어줄 시스템 아키텍처가 가진 속성을 알고 있어야 한다.

## 2. 두 가지 가치에 대한 이야기
모든 소프트웨어 시스템은 이해관계자에게 서로 다른 두 가지 가치를 제공해야 하는데, **행위(behavior)** 와 **구조(structure)** 가 바로 그것이다.

### 행위
소프트웨어의 첫번쨰 가치는 바로 행위(behavior)다. 많은 프로그래머가 요구사항을 기계에 구현하고 버그를 수정하는 일이 자신의 직업이라고 믿는다. 슬픈 일이지만 그들은 틀렸다.

### 아키텍처
소프트웨어는 '부드러운'과 '제품'의 합성어다. 소프트웨어는 '부드러움을 지니도록' 만들어졌다. 소프트웨어를 만든 이유는 기계의 행위를 쉽게 변경할 수 있도록 하기 위해서다.  
소프트웨어가 가진 본연의 목적을 추구하려면 소프트웨어는 반드시 '부드러워'야 한다. 다시 말해 **변경하기 쉬워야 한다**. 변경사항을 적용하는 데 드는 어려움은 변경되는 범위(scope)에 비례해야 하며, 변경사항의 형태(shape)와는 관련이 없어야 한다.  
**아키텍처는 형태에 독립적이어야 하고, 그럴수록 더 실용적이다.**

### 더 높은 가치
기능과 아키텍처 중 기능보다는 아키텍처가 중요하다. 유연한 아키텍처는 변경이 쉽고 유지보수에도 유리하다.

### 아이젠하워 매트릭스
```text
내겐 두 가지 유형의 문제가 있습니다. 하나는 긴급하며, 다른 하나는 중요합니다. 긴급한 문제는 중요하지 않으며, 중요한 문제는 절대 긴급하지 않습니다.
- 1954년 노스웨스턴 대학교 강연에서 드와이트 D. 아이젠하워 -
```

이 격언은 긴급한 문제가 아주 중요한 문제일 경우는 드물고, 중요한 문제가 몹시 긴급한 경우는 거의 없다는 말로, 소프트웨어에도 대입해 볼 수 있다.  
행위는 긴급하지만 매번 높은 중요도를 가지는 것은 아니다.  
아키텍처는 중요하지만 즉각적인 긴급성을 필요로 하는 경우는 절대 없다.  

아이젠하우 매트릭스 우선순위를 매겨보면 다음과 같다.
1. 긴급하고 중요한
2. 긴급하지는 않지만 중요한
3. 긴급하지만 중요하지는 않은
4. 긴급하지도 중요하지도 않은

아키텍처, 즉 중요한 일은 이 항목의 가장 높은 두 우선순위를 차지하는 반면, 행위는 첫 번째와 세 번째에 위치한다는 점을 주목하자.  
기능의 긴급성이 아니 아키텍처의 중요성을 설득하는 일은 소프트웨어 개발팀이 마땅히 책임져야 한다.

### 아키텍처를 위해 투쟁하라
아키텍처가 후순위가 되면 시스템을 개발하는 비용이 더 많이 들고, 일부 또는 전체 시스템에 변경을 가하는 일이 현실적으로 불가능해진다. 이러한 상황이 발생하도록 용납했다면, 이는 결국 소프트웨어 개발팀이 옳다고 믿는 가치를 위해 충분히 투쟁하지 않았다는 뜻이다.

## 3. 패러다임 개요
### 구조적 프로그래밍
구조적 프로그래밍은 제어흐름으 직접적인 전환에 대해 규칙을 부과한다.

### 객체 지향 프로그래밍
객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 대해 규칙을 부과한다.

### 함수형 프로그래밍
함수형 프로그래밍은 할당문에 대해 규칙을 부과한다.

### 생각할 거리
각 패러다임은 프로그래머에게서 권한을 박탈한다. 즉, 패러다임은 무엇을 해야 할지를 말하기보다는 무엇을 해서는 안 되는지를 말해준다.

### 결론
세 가지 패러다임과 아키텍처의 세 가지 큰 관심사(함수, 컴포넌트 분리, 데이터 관리)가 어떻게 서로 연관되는지에 주목하자.
- 아키텍처 경계를 넘나들기 위한 메커니즘으로 다형성을 이용
- 함수형 프로그래밍을 이용하여 데이터의 위치와 접근 방법에 대해 규칙을 부과
- 모듈의 기반 알고리즘으로 구조적 프로그래밍을 사용

## 4. 구조적 프로그래밍
에츠허르 비버 데이크스트라가 최초 발견.

### 증명
데이크스트라가 초기에 인식한 문제는 프로그래밍은 어렵고, 프로그래머는 프로그래밍을 잘 하지 못한다는 사실이었다.  
데이크스트라는 증명(proof)이라는 수학적인 원리를 적용하여 이 문제를 해결하고자 했다. 프로그래머는 입증된 구조를 이용하고, 이들 구조를 코드와 결합시키며, 그래서 코드가 올바르다는 사실을 스스로 증명하는 방식을 사용할 수 있다고 믿었다.  
데이크스트라느 이와 관련된 연구를 진행하던 중 goto 문장이 모듈을 더 작은 단위로 재귀적으로 분해하는 과정에 방해가 되는 경우가 있다는 사실을 발견했다. 반면 goto 문장이 if/then/else, do/while 과 같은 분기와 반복이라는 단순한 제어구조에 적합하다는 것을 발견했다.  
그는 이러한 제어 구조는 순차 실행과 결합했을 때 특별하다는 사실을 깨달았다.  
이 발견은 실로 놀라웠다. 즉, 모듈을 증명 가능하게 하는 바로 그 제어 구조가 모든 프로그램을 만들 수 있는 제어 구조의 최소 집합과 동일하다는 사실이었다. 구조적 프로그래밍은 이렇게 탄생했다.  
-> goto 문장은 반드시 제어가 있어야만 효용성이 있다는 것을 발견했다는 말인듯..

### 해로운 성명서
1968년 데이크스트라는 "goto문의 해로움"이라는 제목의 기고를 했고, goto문과 관련된 논쟁은 10년 넘게 지속되었다.  
이 논쟁은 결국 데이크스트라의 승리로 끝났으며, 현재의 우리는 모두 구조적 프로그래머이며, 여기에는 선택의 여지가 없다. 제어흐름을 제약없이 직접 전환할 수 있는 선택권 자체를 언어에서 제공하지 않기 때문이다.

### 기능적 분해
구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해할 수 있게 되었고, 이는 결국 모듈을 기능적으로 분해할 수 있음을 뜻했다.  
이를 토대로 구조적 분석이나 구조적 설계와 같은 기법이 1970년대 후반에서 1980년대에 걸쳐 인기를 끌었다. 이들 기법을 사용하면 프로그래머는 대규모 시스템을 모듈과 컴포넌트로 나눌 수 있고, 더 나아가 모듈과 컴포넌트는 입증할 수 있는 아주 작은 기능들로 세분화할 수 있다.

### 결론
구조적 프로그래밍이 오늘날까지 가치있는 이유는 프로그래밍에서 반증 가능한 단위를 만들어 낼 수 있는 바로 이 능력 때문이다.  
가장 작은 기능에서부터 가장 큰 컴포넌트에 이르기까지 모든 수준에서 소프트웨어는 과학과 같고, 따라서 반증 가능성에 의해 주도된다. 소프트웨어 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록(테스트하기 쉽도록) 만들기 위해 분주히 노력해야 한다.

## 5. 객체 지향 프로그래밍
좋은 아키텍처를 만드는 일은 객체 지향(Object-Orientied, OO) 설계 원칙을 이해학 응용하는 데서 출발한다.  
OO의 본질은 캡슐화, 상속, 다형성의 세 가지 개념을 적절하게 조합한 것이거나, 또는 OO 언어는 최소한 세 가지 요소를 반드시 지원해야 한다.

### 캡슐화?
OO를 정의하는 요소 중 하나로 캡슐화를 언급하는 이유는 데이터와 함수를 쉽고 효과적으로 캡슐화하는 방법을 OO 언어가 제공하기 때문이다. 그리고 이를 통해 데이터와 함수가 응집력 있게 구성된 집단을 서로 구분 짓는 선을 그을 수 있다. 구분선 바깥에서 데이터는 은닉되고, 일부 함수만이 외부에 노출된다. 이 개념들이 실제 OO 언어에서는 각각 클래스의 private 멤버 데이터와 public 멤버 함수로 표현된다.  

C언어에서는 선언과 구현의 분리를 통해 완벽한 캡슐화가 가능했으나, C#, java 등의 언어에서는 기술적인 이유로 헤더와 구현체를 분리하는 방식을 모두 버렸고, 이로 인해 캡슐화는 더욱 심하게 훼손되었다. 이들 언어에서는 클래스 선언과 정의를 구분하는 게 아예 불가능하다.  
이 때문에 OO가 강력한 캡슐화에 의존한다는 정의는 받아들이기 힘들다. 실제로 많은 OO 언어가 캡슐화를 거의 강제하지 않는다.  
OO 프로그래밍은 프로그래머가 충분히 올바르게 행동함으로써 캡슐화된 데이터를 우회해서 사용하지 않을 거라는 믿음을 기반으로 한다. 하지만 OO를 제공한다고 주창한 언어들이 실제로는 C언어에서 누렸던 완벽한 캡슐화를 약화시켜 온 것은 틀림없다.

### 상속?
OO 언어가 더 나은 캡슐화를 제공하지는 못했지만, 상속만큼은 OO 언어가 확실히 제공했다.  
하지만 상속이란 단순히 어떤 변수와 함수를 하나의 유효 범위로 묶어서 재정의하는 일에 불과하다. 사실상 OO 언어가 있기 훨씬 이전에도 C프로그래머는 언어의 도움 없이 손수 이러한 방식으로 구현할 수 있었다. 하지만 상속을 흉내내는 요령은 있었지만, 사실상 상속만큼 편리한 방식은 절대 아니었다. 게다가 이 기법을 이용해서 다중 상속을 구현하기란 훨씬 더 어려운 일이었다.  
OO 언어가 완전히 새로운 개념을 만들지는 못했지만, 데이터 구조에 가면을 씌우는 일을 상당히 편리한 방식으로 제공했다고는 볼 수 있다.  
간략히 요약하면, 캡슐화에 대해서는 OO에 점수를 줄 수 없고, 상속에 대해서만 0.5점 정도를 부여할 수 있다. 이렇게만 보면 그저 그런 점수다.

### 다형성?
함수를 가리키는 포인터를 응용한 것이 다형성이다. 이는 곧 OO가 새롭게 만든 것은 전혀 없음을 의미한다.  
하지만, OO 언어는 다형성을 제공하지는 못했지만, 다형성을 좀 더 안전하고 더욱 편리하게 사용할 수 있게 해준다.  
함수에 대한 포인터를 직접 사용하여 다형적 행위를 만드는 이 방식에는 문제가 있는데, 함수 포인터는 위험하다는 사실이다. 이러한 기법은 프로그래머가 특정 관례를 수동으로 따르는 방식이다. 즉, 이들 포인터를 초기화하는 관례를 준수해야 한다는 사실을 기억해야 한다. 만약 프로그래머가 관례를 지켜야 한다는 사실을 망각하게 되면 버그가 발생하고, 이러한 버그는 찾아내고 없애기가 지독히도 힘들다.  
OO 언어는 이러한 관례를 없애주며, 따라서 실수할 위험이 없다. 이러한 이유로 OO는 제어흐름을 간접적으로 전환하는 규칙을 부과한다고 결론지을 수 있다.

#### 다형성이 가진 힘
플러그인 아키텍처는 입출력 장치 독립성을 지원하기 위해 만들어졌고, 등장 이후 거의 모든 운영체제에서 구현되었다. 그럼에도 대다수의 프로그래머는 직접 작성하는 프로그램에서는 이러한 개념을 확장하여 적용하지 않았는데, 함수를 가리키는 포인터를 사용하면 위험을 수반하기 때문이었다.  
OO의 등장으로 언제 어디서든 플러그인 아키텍처를 적용할 수 있게 되었다.

#### 의존성 역전
다형성을 안전하고 편리하게 적용할 수 있는 매커니즘이 등장하기 전 소프트웨어는 제어흐름은 시스템의 행위에 따라 결정되며, 소스 코드 의존성은 제어흐름에 따라 결정되었다.  
하지만 다형성이 끼어들면 무언가 특별한 일이 일어난다.  
![의존성 역전](https://raw.githubusercontent.com/oknyang/oknyang.github.io/master/inversion_of_dependency.png "의존성 역전")  
위 그림에서 HL1 모듈은 ML1 모듈의 F() 함수를 호출한다. 소스 코드에서는 HL1 모듈은 인터페이스를 통해 F() 함수를 호출한다. 이 인터페이스는 런타임에는 존재하지 않는다. HL1은 단순히 ML1 모듈의 함수 F()를 호출할 뿐이다.  
하지만 ML1과 I 인터페이스 사이의 소스 코드 의존성(상속 관계)이 제어흐름과는 반대인 점을 주목하자. 이는 의존성 역전(dependency inversion)이라고 부르며, 소프트웨어 아키텍트 관점에서 이러한 현상은 심오한 의미를 같는다.  
이러한 접근법을 사용한다면, OO 언어로 개발된 시스템을 다루는 소프트웨어 아키텍트는 시스템의 소스 코드 의존성 전부에 대해 방향을 결정하 수 있는 절대적인 권한을 갖는다. 즉, 소스 코드 의존성이 제어흐름의 방향과 일치되도록 제한되지 않는다. 호출하는 모듈이든 아니면 호출받는 모듈이든 관계없이 소프트웨어 아키텍트는 소스 코드 의존성을 원하는 방향으로 설정할 수 있다.  
이것이 바로 OO가 제공하는 힘이다. 그리고 이것이 바로 OO가 지향하는 것이다(최소한 아키텍트의 관점에서는).  
이 힘을 이용해 배포 독립성을 이룰 수 있으며, 시스템의 모듈을 독립적으로 배포할 수 있게 되면, 서로 다른 팀에서 각 모듈을 독립적으로 개발할 수 있다. 그리고 이것이 개발 독립성이다.  

### 결론
소프트웨어 아키텍트 관점에서 OO란 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다. OO를 사용하면 아키텍트는 플러그인 아키텍처를 구성할 수 있고, 이를 통해 고수준의 정책을 포함하는 모듈은 저수준의 세부사항을 포함하는 모듈에 대해 독립성을 보장할 수 있다. 저수준의 세부사항은 중요도가 낮은 플러그인 모듈로 만들 수 있고, 고수준의 정책을 포함하는 모듈과는 독립적으로 개발하고 배포할 수 있다.

## 6. 함수형 프로그래밍
여러가지 의미로, 함수형 프로그래밍이라는 개념은 프로그래밍 그 자체보다 앞서 등장했다. 이 패러다임에서 핵심이 되는 기반은 람다 계산법으로 알론조 처치가 1930년대에 발명했다.

### 정수를 제곱하기
클로저와 자바 프로그램 사이의 극단적 차이를 짚어보면, 자바 프로그램은 가변 변수를 사용하는데, 가변 변수는 프로그램 실행 중에 상태가 변할 수 있다. 클로저 프로그램에서는 이러한 가변 변수가 전혀 없다.   
함수형 언어에서 변수는 변경되지 않는다.

### 불변성과 아키텍처
아키텍처를 고려할 떄 불변성이 왜 중요한가? 우리가 동시성 애플리케이션에서 마주치는 모든 문제, 즉 다수의 스레드와 프로세스를 사용하는 애플리케이션에서 마주치는 모든 문제는 가변 변수가 없다면 절대로 생기지 않는다.  
불변성이 정말로 실현 가능한가? 이 질문에 대한 대답은 대체로 긍정적이다. 단, 저장 공간이 무한하고 프로세서의 속도가 무한히 빠르다고 전제한다면 말이다. 자원이 무한대가 아니라면 대답은 조금 미묘하다. 그래, 불변성은 실현 가능하겠지만 일종의 타협을 해야 한다.  
이제 어떤 타협이 필요한지 살펴보자.

### 가변성의 분리
불변성과 관련하여 가장 주요한 타협 중 하나는 애플리케이션, 또는 애플리케이션 내부의 서비스를 가변 컴포넌트와 불변 컴포넌트로 분리하는 일이다. 불변 컴포넌트는 변수의 상태를 변경할 수 있는, 즉 순수 함수형 컴포넌트가 아닌 하나 이상의 다른 컴포넌트와 서로 통신한다.  
상태 변경은 컴포넌트를 갖가지 동시성 문제에 노출하는 꼴이므로, 흔히 트랜잭션 메모리와 같은 실천법을 사용하여 동시 업데이트와 경합 조건 문제로부터 가변 변수를 보호한다.  
애플리케이션을 제대로 구조화하려면 변수를 변경하는 컴포넌트와 변경하지 않는 컴포넌트를 분리해야 한다. 그리고 이렇게 분리하려면 가변 변수들을 보호하는 적절한 수단을 동원해 뒷받침 해야 한다.  
현명한 아키텍트라면 가능한 한 많은 처리를 불변 컴포넌트로 옮겨야 하고, 가변 컴포넌트에서는 가능한 한 많은 코드를 빼내야 한다.

### 이벤트 소싱
이벤트 소싱은 상태가 아닌 트랜잭션을 저장하자는 전략이다. 상태가 필요해지면 단순히 상태의 시작점부터 모든 트랜잭션을 처리한다.  
이제 이 전략에 필요한 데이터 저장소에 대해 생각해 보자. 아마 저장 공간이 많이 필요할 것이다. 실제로 오프라인 데이터 저장소는 급격하게 증가하여 이제는 수 테라바이트도 작다고 여기는 시대다. 따라서 우리는 저장 공간을 충분히 확보할 수 있다.  
더 중요한 점은 데이터 저장소에서 삭제되거나 변경되는 것이 하나도 없다는 사실이다. 결과적으로 애플리케이션은 CRUD가 아니라 그저 CR만 수행한다. 또한 데이터 저장소에서 변경과 삭제가 전혀 발생하지 않으므로 동시 업데이트 문제 또한 일어나지 않는다.  
저장 공간과 처리 능력이 충분하면 애플리케이션이 완전한 불변성을 갖도록 만들 수 있고, 따라서 완전한 함수형으로 만들 수 있다.  
이 이야기가 여전히 터무니없게 들린다면, 소스 코드 버전 관리 시스템이 정확히 이 방식으로 동작한다는 사실을 떠올려 보면 도움이 될 것이다.

### 결론
요약하면 
* 구조적 프로그래밍은 제어흐름의 직접적인 전환에 부과되는 규율이다.
* 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 부과되는 규율이다.
* 함수형 프로그래밍은 변수 할당에 부과되는 규율이다.

이들 세 패러다임 모두 우리에게서 무언가를 앗아갔다. 각 패러다임은 우리가 코드를 작성하는 방식의 형태를 한정시킨다. 어떤 패러다임도 우리의 권한이나 능력에 무언가를 보태지는 않는다.  
지난 반세기 동안 도구는 달라졌고 하드웨어도 변했지만, 소프트웨어의 핵심은 여전히 그대로다.  
소프트웨어, 즉 컴퓨터 프로그램은 순차, 분기, 반복, 참조로 구성된다. 그 이상도 이하도 아니다.
