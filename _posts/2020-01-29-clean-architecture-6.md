---
title: "clean architecture 6"
date: 2020-01-29
categories: architecture
---

## 30. 데이터베이스는 세부사항이다
아키텍처 관점에서 볼 때 데이터베이스는 엔티티가 아니다. 애플리케이션 내부 데이터의 구조는 시스템 아키텍처에서 대단히 중요하다. 하지만 데이터베이스는 데이터 모델이 아니다.

### 관계형 데이터베이스
에드거 커드는 1970년에 관계형 데이터베이스의 원칙을 정의했다. 관계형 데이터베이스는 데이터를 저장하고 접근하는 데 탁월한 기술이었다.  
관계형 테이블은 특정한 형식의 데이터에 접근하는 경우에는 편리하지만, 데이터를 테이블에 행 단위로 배치한다는 자체는 아키텍처적으로 볼 때 전혀 중요하지 않다. 애플리케이션의 유스케이스는 이러한 방식을 알아서는 안되며 관여해서도 안 된다. 데이터가 테이블 구조를 가진다는 사실은 오직 아키텍처의 외부 원에 위치한 최하위 수준의 유틸리티 함수만 알아야 한다.  
많은 데이터 접근 프레임워크가 테이블과 행이 객체 형태로 시스템 여기저기에서 돌아다니게 허용하는데, 아키텍처적으로 잘못된 설계다. 이렇게 하면 유스케이스, 업무규칙, 심지어는 UI조차도 관계형 데이터 구조에 결합되어 버린다.

### 데이터베이스 시스템은 왜 이렇게 널리 사용되는가?
한마디로 답하자면 '디스크' 때문이었다.  
지난 반세기 동안 회전식 자기 티스크는 데이터 저장소의 중심에 있었다.  
디스크 때문에 피해갈 수 없는 시간 지연이라는 짐을 완화하기 위해, 색인, 캐시, 쿼리 계획 최적화가 필요해졌다. 그리고 데이터를 표현하는 일종의 표준적인 방식도 필요했는데, 이러한 색인, 캐시, 쿼리 계획에서 작업중인 대상이 어떤 데이터인지 알 수 있어야 했기 때문이다. 간단히 말해서 데이터 접근 및 관리 시스템이 필요했다. 시간이 지나면서 이러한 시스템은 뚜렷이 구분되는 두 가지 유형으로 분리되었다. 하나는 파일시스템이었고, 다른 하나는 관계형 데이터베이스 관리 시스템이었다.  
파일시스템은 문서(document) 기반이다. 파일시스템은 문서 전체를 자연스럽고 편리하게 저장하는 방법을 제공한다. 일련의 문서를 이름을 기준으로 저장하거나 조회할 때는 잘 동작하지만, 내용을 기준으로 검색할 때는 그리 크게 도움되지 않는다.  
데이터베이스 시스템은 내용 기반이다. 데이터베이스 시스템은 내용을 기반으로 레코드를 자연스럽고 편리하게 찾는 방법을 제공한다. 레코드가 서로 공유하는 일부 내용에 기반해서 다수의 레코드를 연관 짓는 데 매우 탁월하다. 하지만 안타깝게도 정형화되지 않은 문서를 저장하고 검색하는 데는 대체로 부적합하다.  
이들 두 시스템은 데이터를 디스크에 체계화해서, 각 시스템에 특화된 방식으로 접근해야 할 때 가능한 한 효율적으로 데이터를 저장하고 검색할 수 있도록 한다. 각 시스템은 데이터를 색인하고 배치하는 고유한 전략을 활용한다. 덧붙여 말하자면, 데이터를 빠르게 조작할 수 있도록 결국에는 관련 있는 데이터를 RAM으로 가져온다. 

### 디스크가 없다면 어떻게 될까?
디스크는 RAM으로 대체되고 있다.  
디스크가 모두 사라진다면, 그래서 모든 데이터가 RAM에 저장된다면 데이터를 어떻게 체계화 할 것인가?  
이 데이터들을 연결 리스트, 트리, 해시 테이블, 스택, 큐 혹은 여타 무수히 많은 데이터 구조로 체계화할 것이며, 데이터에 접근할때는 포인터나 참조를 사용할 것이다. 이것이 프로그래머가 하는 일이기 때문이다.  
사실 이 문제를 곰곰이 생각해 보면, 당신은 이미 이렇게 일하고 있다는 사실을 알아챌 것이다. 데이터가 데이터베이스나 파일 시스템에 있더라도, RAM으로 읽은 후에는 다루기 편리한 형태로 그 구조를 변경한다. 리스트, 집합, 스택, 큐, 트리 등 입맛에 맞는 임의의 구조로 말이다. 데이터를 파일이나 테이블 형태로 그대로 두는 경우는 거의 없다.  

### 세부사항
데이터베이스가 세부사항이라고 말하는 이유는 바로 이러한 현실 때문이다. 데이터베이스는 그저 메커니즘에 불과하며, 디스크 표면과 RAM 사이에서 데이터를 이리저리 옮길 때 사용할 뿐이다.  
따라서 아키텍처 관점에서 본다면 회전식 자기 디스크에 데이터가 있기만 한다면, 데이터가 어떤 형태인지는 절대로 신경써서는 안된다.

### 하지만 성능은
성능은 아키텍처적인 관심사이지만 데이터 저장소의 측면에서 성능은 완전히 캡슐화하여 업무 규칙과는 분리할 수 있는 관심사다. 데이터 저장소에서 데이터를 빠르게 넣고 뺄 수 있어야 하는 것은 맞지만, 이는 저수준의 관심사다. 성능은 시스템의 전반적인 아키텍처와는 아무런 관련이 없다.

### 결론
체계화된 데이터 구조와 데이터 모델은 아키텍처적으로 중요하다. 반면, 그저 데이터를 회전식 자기 디스크 표면에서 이리저리 옮길 뿐인 기술과 시스템은 아키텍처적으로 중요치 않다. 관계형 데이터베이스 시스템은 전자보다는 후자와 훨씬 관련이 깊다. 데이터는 중요하다. 데이터베이스는 세부사항이다.

## 31. 웹은 세부사항이다
### 끝없이 반복하는 추
연산능력을 중앙에 집중하는 방식과 분산하는 방식 사이에서 우리는 끊임없이 움직인다. 그리고 이러한 진동은 한동안 계속될 것이다.  
아키텍트로서 우리는 멀리 내다봐야 한다. 이 진동은 그저 핵심 업무 규칙의 중심에서 밀어내고 싶은 단기적인 문제일 뿐이다.  

### 요약
GUI는 세부사항이다. 웹은 GUI다. 따라서 웹은 세부사항이다. 그리고 아키텍트라면 이러한 세부사항을 핵심 업무 로직에서 분리된 경계 바깥에 두어야 한다.  

## 32. 프레임워크는 세부사항이다
프레임워크는 상당한 인기를 끌고 있다. 무료인데다 강력하며 유용한 프레임워크가 많다.  
하지만 아무리 해도 프레임워크는 아키텍처가 될 수 없다. 

### 프레임워크 제작자
대다수의 프레임워크 제작자는 커뮤니티에 도움이 되기를 바라는 마음에 자신의 작업물을 무료로 제공한다. 하지만 고상한 동기와 관계없이, 이들은 당신이 풀어야 할 특별한 관심사를 염두에 두지 않는다. 프레임워크 제작자는 당신을 알지 못하며, 당신이 풀어야 할 문제도 알지 못하기 때문이다.  
물론 당신의 문제는 프레임워크가 풀려는 문제와 꽤 많이 겹칠 것이다. 겹치지 않았다면 프레임워크가 그렇게 인기를 끌지는 못했을 것이다. 겹치는 영역이 크면 클수록 프레임워크는 실제로 더 유용해진다.

### 혼인관계의 비대칭성
당신과 프레임워크 제작자 사이의 관계는 놀라울 정도로 비대칭적이다. 당신은 프레임워크를 위해 대단히 큰 헌신을 해야 하지만, 프레임워크 제작자는 당신을 위해 아무런 헌신도 하지 않는다.  
대개의 경우 프레임워크 제작자들은 프레임워크를 중심에 두고 우리의 아키텍처는 그 바깥을 감싸야 한다고 말한다. 또한 이들은 프레임워크의 기반 클래스에서 직접 파생하거나, 프레임워크의 기능들을 업무 객체에 바로 임포트해서 사용하라고 권한다. 프레임워크 제작자는 당신의 애플리케이션이 가능하면 프레임워크에 공고하게 결합될 것을 강하게 역설한다.  
프레임워크 제작자 입장에서는 프레임워크와의 이러한 결합이 위험 요소가 되지 않는다. 오히려 프레임워크와 결합되기를 바란다. 왜냐하면 제작자는 그 프레임워크에 대해 절대적인 제어권을 쥐고 있기 때문이다.  
한술 더 떠서 제작자는 당신도 자신의 프레임워크에 결합되기를 바란다. 한번 결합하면 그 관계를 깨기가 매우 어렵기 때문이다.  
사실상 프레임워크 제작자는 당신에게 프레임워크와 혼인하기를 요구하는 것이다. 즉, 프레임워크에 대해 장기가에 걸친 막대한 헌신을 요청하는 것이다. 그럼에도 프레임워크 제작자는 어떠한 경우에도 그에 상응하는 헌신을 당신에게 하지는 않을 것이다. 이 혼인 관계는 일방적이다. 모든 위험과 부담은 오롯이 당신이 감수할 뿐, 제작자가 감수하는 건 아무것도 없다.  

### 위험 요인
앞서 말한 위험 요인은 다음과 같다.
* 프레임워크의 아키텍처는 그다지 깔끔하지 않은 경우가 많다. 프레임워크는 의존성 규칙을 위반하는 경향이 있다. 업무 객체를 만들 때, 프레임워크 제작자는 자신의 코드를 상속할 것을 요구한다. 당신만의 고유한 엔티티를 만들 때 말이다! 프레임워크 제작자는 자신의 프레임워크가 당신의 가장 안쪽 원과 결합되기를 원한다. 하지만 프레임워크가 한번 안으로 들어가버리면 다시는 원 밖으로 나오지 않을 것이다. 결혼반지는 이미 당신의 손가락에 끼워졌고, 다시는 빼지 못할 것이다.  
* 프레임워크는 애플리케이션의 초기 기능을 만드는 데는 도움이 될 것이다. 하지만 제품이 성숙해지면서 프레임워크가 제공하는 기능과 틀을 벗어나게 될 것이다. 결혼반지를 꼈다면, 시간이 지나면서 프레임워크와 계속 싸우고 있는 자신을 발견하게 될 것이다.  
* 프레임워크는 당신에게 도움되지 않는 방향으로 진화할 수도 있다.  
* 새롭고 더 나은 프레임워크가 등장해서 갈아타고 싶을 수도 있다.

### 해결책
프레임워크와 결혼하지 말라!  
프레임워크를 사용할 수는 있다. 다만 프레임워크와 결합해서는 안 된다. 적당히 거리를 두자.  
업무 객체를 만들 때 프레임워크가 자신의 기반 클래스로부터 파생하기를 요구한다면, 거절하라! 대신 프락시를 만들고, 업무 규칙에 플러그인할 수 있는 컴포넌트에 이들 프락시를 위치시켜라.  
프레임워크가 핵심 코드 안으로 들어오지 못하게 하라. 대신 핵심 코드에 플러그인할 수 있는 컴포넌트에 프레임워크를 통합하고, 의존성 규칙을 준수하라.  
예를 들어 당신은 스프링을 좋아할 것이다. 스프링은 훌륭한 의존성 주입 프레임워크다. 아마도 의존성을 연결할 때 스프링의 오토와이어링 기능을 사용할 것이다. 이 방법도 괜찮지만, @Autowired 어노테이션이 업무 객체 도처에 산재해서는 안 된다. 업무 객체는 절대로 스프링에 대해 알아서는 안 된다.  
업무 객체보다는 메인 컴포넌트에서 스프링을 사용해서 의존성을 주입하는 편이 낫다. 메인은 아키텍처 내에서 가장 지저분한, 최저 수준의 컴포넌트이기 때문에 스프링을 알아도 상관 없다.  

### 이제 선언합니다.
정말로 결혼해야만 하는 프레임워크도 존재한다. 자바를 사용한다면 표준 라이브러리와 반드시 결혼해야 한다.  
이러한 관계는 정상이다. 하지만 선택적이어야 한다. 애플리케이션이 프레임워크와 결혼하고자 한다면 애플리케이션의 남은 생애 동안 그 프레임워크와 항상 함께 해야 한다는 사실을 반드시 명심해야 한다. 결코 가볍게 시작할 수 있는 관계가 아니다.

### 결론
프레임워크와의 첫만남부터 바로 결혼하려 들지 말라. 결혼 서약에 앞서 잠시 동안 연애를 할 수 있는 방법이 있는지 확인하라. 가급적이면 프레임워크를 가능한 한 오랫동안 아키텍처 경계 너머에 두자.

