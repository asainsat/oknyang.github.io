---
title: "java 8"
date: 2019-12-02
categories: java
---

## 1. 람다
메서드로 전달할 수 있는 익명 함수를 단순화 한 것.

### 람다 특징
* 익명 : 메서드 이름 없음
* 함수 : 메서드처럼 특정 클래스에 종속되지 않으므로 함수라고 부름.
* **전달** : 람다 표현식을 메서드 인수로 전달하거나 변수로 저장할 수 있음.
* 간결성

## 2. 스트림
데이터 컬렉션 반복을 선언적으로 처리하는 기능.  
(명령형은 어떻게 할 것인지 설명(how), 선언형은 무엇을 할 것인지 정의(what)).  

### 스트림 장점
* 선언형 : 간결함, 가독성 향상
* 조립 : 유연성 향상
* 병렬화 : 성능 향상

### 스트림의 정의
**데이터 처리 연산**을 지원하도록 **소스**에서 추출된 **연속된 요소**

* 연속된 요소 : 특정 요소 형식으로 이루어진 값 집합의 인터페이스를 제공한다.  
자료구조적으로 접근하는 컬렉션과 달리 스트림은 fileter, sorted, map 처럼 표현 계산식이 주를 이룬다.  
**즉, 컬렉션의 주제는 데이터고 스트림의 주제는 계산이다.**

* 소스 : 스트림은 컬렉션, 배열, I/O 자원 등의 데이터 제공 소스로부터 데이터를 소비한다.

* 데이터 처리 연산 : 함수형 프로그래밍 언어에서 일반적으로 지원하는 연산과 데이터베이스와 비슷한 연산을 지원한다.  

### 스트림 특징
* 파이프라이닝 : 스트림 연산끼리 연결해서 커라달 파이프라인을 구성할 수 있도록 스트림 자신을 반환
* 내부 반복 : 반복자를 이용해서 명시적으로 반복하는 컬렉션과 달리 스트림은 내부 반복을 지원함.  

### 스트림과 컬렉션
![streamcollection](https://raw.githubusercontent.com/oknyang/oknyang.github.io/master/streamVScolletion.png "stream VS collections")

### 스트림 연산
파이프라인을 만들어 연결할 수 있는 스트림 연산을 **중간 연산**이라고 하며, 스트림을 닫는 연산을 **최종 연산**이라고 한다.

#### 중간 연산
* 중간 연산(filter, sorted...)은 다른 스트림을 반환. -> 여러 중간 연산을 연결해서 질의할 수 있다.
* 단말 연산을 스트림 파이프라인에 실행하기 전까지는 아무 연산도 수행하지 않음. -> **게으르다(lazy)**
* 중간 연산을 합친 다음, 합쳐진 중간 연산을 최종 연산으로 한번에 처리.

#### 최종 연산
* 스트림 파이프라인에서 결과를 도출.
* 스트림 이외의 결과가 반환.

## 3. 스트림 활용
### 필터링과 슬라이싱
* filter : predicate(boolean을 반환하는 함수)를 인수로 받아서 predicate와 일치하는 모든 요소를 포함하는 스트림을 반환.
* distinct : 고유 요소로 이루어진 스트림을 반환. (hashCode, equals로 결정)
* limit : 주어진 사이즈 이하의 크기를 갖는 새로운 스트림을 반환.
* skip : 처음 n개 요소를 제외한 스트림을 반환.

### 매핑
#### map
* 스트림은 함수를 인수로 받는 map 메서드를 지원한다. 인수로 제공된 함수는 각 요소에 적용되며 함수를 적용한 결과가 새로운 요소로 매핑된다.
```java
// Stream<Dish> 에서 Stream<String>으로 변환.
 List<String> dishName = menu.stream().map(Dish::getName).collect(toList());
```

#### flatMap
* 각 배열을 스트림이 아니라 스트림의 콘텐츠로 매핑한다.
* 스트림의 각 값을 다른 스트림으로 만든 다음에 모든 스트림을 하나의 스트림으로 연결하는 기능을 수행.

### 검색과 매칭
* anyMatch : 프레디케이트가 주어진 스트림에서 적어도 한 요소와 일치하는지 확인.
* allMatch : 스트림의 모든 요소가 주어진 프레디케이트와 일치하는지 확인.
* noneMatch : 주어진 프레디케이트와 일치하는 요소가 없는지 확인.

#### 쇼트서킷
표현식에서 하나라도 거짓이라는 결과가 나오면 나머지 표현식의 결과와 상관없이 전체 결과도 거짓이 된다. 이러한 상황을 쇼트서킷이라고 부름. 
allMatch, noneMatch, findFirst, findAny, limit 등이 쇼트서킷 연산.

#### Optional
Optional<T> 클래스는 값의 존재나 부재 여부를 표현하는 컨테이너 클래스.  
값이 존재하는지 확인하고 값이 없을 떄 어떻게 처리할 것인지 강제하는 기능을 제공.  
* isPresent() : Optional이 값을 포함하면 true, 포함하지 않으면 false.
* ifPresent(Consumer<T> block) : 값이 있으면 주어진 블록을 실행.
* T get() : 값이 존재하면 값 반환, 없으면 NoSuchElementException
* T orElse(T other) : 값이 있으면 값 반환, 없으면 기본값 반환.

#### findFirst, findAny
병렬실행에서는 첫번째 요소를 찾기 어렵기 때문에, 요소의 반환 순서가 상관 없다면 병렬 스트림에서는 제약이 적은 findAny를 사용한다.

### 리듀싱
* 리듀싱 연산 : 모든 스트림 요소를 처리해서 값으로 도출.

#### reduce 메서드의 장점과 병렬화
reduce를 이용하면 내부 반복이 추상화 되면서 내부 구현에서 병렬로 reduce를 실행할 수 있게 된다. 반복작업으로 합계를 구하는 방식은 쉽게 병렬화하기 어렵다.

#### 스트림 연산 : 상태 없음과 상태 있음
* 내부 상태를 갖지 않는 연산 : map, filter 등... 스트림에서 각 요소를 받아 결과를 출력 스트림으로 내보냄. 이들은 내부 상태를 갖지 않음.
* 한정된 내부 상태를 갖는 연산 : reduce, sum, max 등.. 연산 결과를 누적할 필요가 있기에, 스트림에서 처리하는 요소 수와 관계 없이 한정된 내부 상태를 갖는다.
* 내부 상태를 갖는 연산 : sorted, distinct 등.. 정렬이나 중복제거는 과거의 이력을 알고 있어야 한다. 내부 저장소 크기가 정해져 있기 않기에 스트림 크기가 크거나 무한이면 문제가 발생할 수 있다.

### 숫자형 스트림
* 기본형 특화 스트림은 오직 박싱 과정에서 일어나는 효율성과 관련이 있다.
* 기본형 특화 스트림 : IntStream, DoubleStream, LongStream.
* OptionalInt, OptionalDouble, OptionalLong : 스트림에 요소가 없는 상황과 실제 값이 0인 상황을 구분. 값이 없는 상황에 사용할 기본값을 명시적으로 정의할 수 있다.
* range : 시작값과 종료값이 결과에 포함되지 않음
* rangeClosed : 시작값과 종료값이 결과에 포함됨.

```java
// 숫자 스트림으로 매핑
int calories = menu.stream().mapToInt(Dish::getCalories).sum();

// 객체 스트림으로 복원
IntStream intStream = menu.stream().mapToInt(Dish::getCalories);
Stream<Integer> stream = intStream.boxed();

// OptionalInt
OptionalInt maxCalories = menu.stream().mapToInt(Dish::getCalories).max();
int max = maxCalories.orElse(1);
```

### 스트림 만들기
#### 무한 스트림 (언바운드 스트림)
* 크기가 고정되지 않은 스트림
* Stream.iterate와 Stream.generate로 만들 수 있음.
* iterate는 연속된 값을 무한 생성, generate는 Supplier<T>를 인수로 받아서 새로운 값을 생성.

```java
// iterate
Stream.iterate(0, n -> n + 2).limit(10).forEach(System.out::println);

// generate
Stream.generate(Math::random).limit(5).forEach(System.out::println);
```

## 4. 스트림으로 데이터 수집
### 컬렉터란?
Collector 인터페이스 구현은 스트림의 요소를 어떤 식으로 도출할지 지정한다. 
고급 리듀싱 기능을 수행. - collect에서는 리듀싱 연산을 이용해 스트림의 각 요소를 방문하면서 컬렉터가 작업을 처리한다. 
보통 함수를 요소로 변환할 때는 컬렉터를 적용하며 최종 결과를 저장하는 자료구조에 값을 누적한다. 

* Collectors에서 제공하는 메서드의 기능
  - 스트림 요소를 하나의 값으로 리듀스하고 요약
  - 요소 그룹화
  - 요소 

#### 리듀싱과 요약
* 요약 연산 : 리듀싱 기능을 사용하여 스트림에 있는 객체의 숫자 필드의 합계나 평균 등을 반환하는 연산.
* 최대값 최소값 : Collectors.maxBy, Collectors.minBy
* 단순 합계, 평균값 계산 등 : Collectors.summingInt, Collectors.summingDouble, Collectors.averagingInt 등
* 두 개 이상의 연산을 한번에 수행해야 할 때 : Collectors.summarizingInt, Collectors.summerizingDouble 등
* 문자열 연결 : Collectors.joining
* 범용 리듀싱 요약 연산 : 위의 모든 컬렉터는 Collectors.reducing 펙토리 메서드로도 정의할 수 있다.

```java
// summarizingInt
IntSummaryStatistics menuStatistics = menu.stream().collect(Collectors.summarizingInt(Dish::getCalories));
```
```
// menuStatistics 출력 결과
IntSummaryStatistics { count=9, sum=4300, min=120, average=477.777778, max=800 }
```

##### collect와 reduce

```java
// Collectors.toList 대신 reduce를 사용한 예
Stream<Integer> stream = Arrays.asList(1, 2, 3, 4, 5, 6).stream();
List<Integer> numbers = stream.reduce(
                               new ArrayList<Integer>(),
                               (List<Integer> l, Integer e) -> {
                                         l.add(e);
                                         return l; },
                               (List<Integer> l1, List<Integer> l2) -> {
                                         l1.addAll(l2);
                                         return l1; });
```
위 코드에는 의미론적인 문제와 실용성 문제 등 두 가지 문제가 발생한다.  
collect 메서드는 도출하려는 결과를 누적하는 컨테이너를 바꾸도록 설계된 메서드인 반면 reduce는 두 값을 하나로 도출하는 불변형 연산이라는 점에서 의미론적인 문제가 일어난다.  
즉, 위 예제에서 reduce 메서드는 누적자로 사용된 리스트를 변환시키므로 reduce를 잘못 활용한 예에 해당한다.  
여러 스레드가 동시에 같은 데이터 구조체를 고치면 리스트 자체가 망가져버리므로 리듀싱 연산을 병렬로 수행할 수 없다는 점도 문제이다.  
가변 컨테이너 관련 작업이면서 병렬성을 확보하려면 collect 메서드로 리듀싱 연산을 구현하는 것이 바람직하다.  

#### 그룹화
Collectors.groupingBy : 데이터 집합을 하나 이상의 특성으로 분류해서 그룹화.

##### 다수준 그룹화
collectors.groupingBy 중첩 사용해서 다수준으로 그룹핑할 수 있음.

```java
Map<Dish.Type, Map<CaloricLevel, List<Dish>>> dishesByTypeCaloricLevel = 
menu.stream().collect(
     Collectors.groupingBy(Dish::getType, 
                           Collectors.groupingBy(dish -> {
                                      if (dish.getCalories() <= 400) {
                                           return CalloricLevel.DIET;
                                      }
                                      return CalloricLevel.NORMAL;
                                  }
                           })
     )
);         
```

##### 서브그룹으로 데이터 수집
분류 함수 한 개의 인수를 갖는 groupingBy(f)는 사실 groupingBy(f, toList())의 축약형.  
toList 대신 다른 컬렉터를 사용하거나, 컬렉터 결과를 다른 형식에 적용하는 등의 활용이 가능하다.

#### 분할
Collectors.partitioningBy()  
분할은 분할 함수라 불리는 프레디케이트를 분류 함수로 사용하는 특수한 그룹화 기능이다.
분할 함수는 불린을 반환하므로 맵의 키 형식은 Boolean이다. 결과적으로 그룹화 맵은 최대 (참 또는 거짓) 두 개의 그룹으로 분류된다.

#### Collector 인터페이스
Collector 인터페이스는 리듀싱 연산(즉, 컬렉터)을 어떻게 구현할지 제공하는 메서드 집합으로 구성된다.

```java
// T : 수집될 스트림 항목의 제네릭 형식
// A : 누적자, 즉 수집 과정에서 중간 결과를 누적하는 객체의 형식
// R : 수집 연산 결과 객체의 형식
public interface Collector<T, A, R> {
   Supplier<A> supplier();
   BiConsumer<A, T> accumulator();
   Function<A, R> finisher();
   BinaryOperator<A> combiner();
   Set<Characteristics> characteristics();
}
```

##### Collector 인터페이스의 메서드
###### supplier : 새로운 결과 컨테이너 만들기.  
빈 결과로 이루어진 Supplier를 반환해야 한다. 즉, supplier는 수집 과정에서 빈 누적자 인스턴스를 만드는 파라미터가 없는 함수다.

```java
public Supplier<List<T>> supplier() {
   return () -> new ArrayList<T>();
}
```

###### accumulator : 결과 컨테이너에 요소 추가하기.  
accumulator 메서드는 리듀싱 연산을 수행하는 함수를 반환한다. 누적자와 n번째 요소를 함수에 적용한다.

```java
public BiConsumer<List<T>, T> accumulator() {
   return (list, item) -> list.add(item);
}
```

###### finisher : 최종 변환값을 컨테이너로 적용하기.  
finisher 메서드는 스트림 탐색을 끝내고 누적자 객체를 최종 결과로 변환하면서 누적 과정을 끝낼 때 호출할 함수를 반환해야 한다.  
누적자 객체가 이미 최종 결과인 상황에서는 변환과정이 필요하지 않으므로 finisher 메서드는 항등 함수를 반환한다.

```java
public Function<List<T>, List<T>> finisher() {
   return Function.identity();
}
```

###### combiner : 두 결과 컨테이너 병합
combiner는 스트림의 서로 다른 서브파트를 병렬로 처리할 때 누적자가 이 결과를 어떻게 처리할지 정의한다.
이 메서드를 이용하면 스트림의 리듀싱을 병렬로 수행할 수 있다.

###### 스트림의 병렬 리듀싱 수행 과정.
1. 스트림을 분할해야 하는지 정의하는 조건이 거짓으로 바뀌기 전까지 원래 스트림을 재귀적으로 분할한다. (보통 분산된 작업의 크기가 너무 작아지면 병렬 수행의 속도는 순차 수행의 속도보다 느려진다. 즉, 병렬 수행의 효과가 상쇄된다. 일반적으로 프로세싱 코어의 개수를 초과하는 병렬 작업은 효율적이지 않다.)

2. 이제 모든 서브스트림의 각 요소에 리듀싱 연산을 순차적으로 젹용해서 서브스트림을 병렬로 처리할 수 있다.

3. 마지막에는 컬렉터의 combiner 메서드가 반환하는 함수로 모든 부분결과를 쌍으로 합친다. 즉, 분할된 모든 서브스트림의 결과를 합치면서 연산이 완료된다.

###### Characteristics
컬렉터의 연산을 정의하는 Characteristics 형식의 불변 집합을 반환한다. Characteristics는 스트림을 병렬로 리듀스 할 것인지 그리고 병렬로 리듀스 한다면 어떤 최적화를 선택해야 할지 힌트를 제공한다.

* UNORDERED :  
 리듀싱 결과는 스트림 요소의 방문 순서나 누적 순서에 영향을 받지 않는다.

* CONCURRENT :  
 다중 스레드에서 accumulator 함수를 동시에 호출할 수 있으며 이 컬렉터는 스트림의 병렬 리듀싱을 수행할 수 있다. 컬렉터의 플래그에 UNORDERED를 함께 설정하지 않았다면 데이터 소스가 정렬되어 있지 않은 상황에서만 병렬 리듀싱을 수행할 수 있다.

* IDENTITY_FINISH :  
 finisher 메서드가 반환하는 함수는 단순히 identity를 적용할 뿐이므로 이를 생략할 수 있다. 따라서 리듀싱 과정의 최종 결과로 누적자 객체를 바로 사용할 수 있다.

##### 컬렉터 구현을 만들지 않고도 커스텀 수집 수행하기
```java
List<Dish> dishes = menuStream.collect(
                            ArrayList::new, // supplier
                            List::add, // accumulator
                            List::addAll); // combiner
```

## 5. 병렬 데이터 처리
### 병렬 스트림
컬렉션에 parallelStream을 호출하면 병렬스트림이 생성된다.  
**병렬 스트림이란 각각의 스레드에서 처리할 수 있도록 스트림 요소를 여러 청크로 분할한 스트림**이다.

```java
public static parallelSum(long n) {
   return Stream.iterate(1L, i -> i + 1)
                .limit(n)
                .parallel() // 스트림을 병렬 스트림으로 변환
                .reduce(0L, Long::sum); // 병렬로 처리됨.
}
```
순차 스트림에 perallel을 호출하면 이후 연산이 병렬로 수행되어야 함을 의미하는 불린 플래그가 설정된다. 반대로 sequential로 병렬 스트림을 순차 스트림으로 바꿀 수 있다. perallel과 sequential 두 메스드 중 최종적으로 호출된 메서드가 전체 파이프라인에 영향을 미친다.

```java
stream.parallel()
      .filter(...) // 병렬
      .sequential()
      .map(...) // 순차
      .parallel()
      .reduce(); // 병렬
```

병렬 스트림은 내부적으로 ForkJoinPool을 사용한다. 기본적으로 ForkJoinPool은 프로세서 수(Runtime.getRuntime().availableProcessors()가 반환하는 값)에 상응하는 스레드를 갖는다.  
병렬처리시 공유된 가변 상태를 피해야 한다.  

#### 병렬 스트림 효과적으로 사용하기
1. 확신이 서지 않는다면 직접 측정하라.  
 언제나 병렬 스트림이 순차 스트림보다 빠른 것은 아니다. 더욱이 병렬 스트림의 수행 과정은 투명하지 않을 때가 많다. 따라서 순차 스트림과 병렬 스트림 중 어떤 것이 좋을지 모르겠다면 적절한 벤치마크로 직접 성능을 측정하는 것이 바람직하다.
2. 박싱을 주의하라.  
 자동 박싱과 언박싱은 성능을 크게 저하시킬 수 있는 요소다. 자바8은 박싱 동작을 피할 수 있도록 기본형 특화 스트림(IntStream, LongStream, DoubleStream)을 제공한다.
3. 순차 스트림보다 병렬 스트림에서 성능이 떨어지는 연산이 있다.  
 limit나 findFirst처럼 요소의 순서에 의존하는 연산을 병렬 스트림에서 수행하려면 비싼 비용을 치러야 한다. 정렬된 스트림에 unordered를 호출하면 비정렬된 스트림을 얻을 수 있다. 스트림에 N개 요소가 있을 떄 요소의 순서가 상관없다면 비정렬된 스트림에 limit를 호출하는 것이 더 효율적이다.
4. 스트림에서 수행하는 전체 파이프라인 연산 비용을 고려하라.  
 처리해야 할 요소 수가 N이고 하나의 요소를 처리하는 데 드는 비용을 Q라 하면 전체 스트림 파이프라인 처리 비용은 N * Q로 예상할 수 있다. Q가 높아진다는 것은 병렬 스트림으로 성능을 개선할 수 있는 가능성이 있음을 의미한다.
5. 소량의 데이터에서는 병렬 스트림이 도움 되지 않는다.  
 소량의 데이터를 처리하는 상황에서는 병렬화 과정에서 생기는 부가 비용을 상쇄할 수 있을 만큼의 이득을 얻지 못하기 때문이다.
6. 스트림을 구성하는 자료구조가 적절한지 확인하라.  
 예를 들어 ArrayList를 LinkedList보다 효율적으로 분할할 수 있다. LinkedList를 분할하려면 모든 요소를 탐색해야 하지만 ArrayList는 요소를 탐색하지 않고도 리스트를 분할할 수 있기 때문이다.
7. 스트림의 특성과 파이프라인의 중간 연산이 스트림의 특성을 어떻게 바꾸는지에 따라 분해 과정의 성능이 달라질 수 있다.  
 예를 들어 SIZED 스트림은 정확히 같은 크기의 두 스트림으로 분할할 수 있으므로 효과적으로 스트림을 병렬처리할 수 있다. 반면 필터 연산이 있으면 스트림의 길이를 예측할 수 없으므로 효과적으로 스트림을 병렬 처리할 수 있을지 알 수 없게 된다.
8. 최종 연산의 병합 과정 (Collector의 combiner 등) 비용을 살펴보라.  
 병합 과정의 비용이 비싸다면 병렬 스트림으로 얻은 성능의 이익이 서브스트림의 부분결과를 합치는 과정에서 상쇄될 수 있다.

### 포크/조인 프레임워크
포크/조인 프레임워크는 병렬화 할 수 있는 작업을 재귀적으로 작은 작업으로 분할한 다음에 서브태스크의 각각의 결과를 합쳐서 전체 결과를 만들도록 설계되었다.  
포크/조인 프레임워크에서는 서브태스크를 스레드 풀(ForkJoinPool)의 작업자 스레드에 분산 할당하는 ExecutorService 인터페이스를 구현한다.

#### RecursiveTask 활용







