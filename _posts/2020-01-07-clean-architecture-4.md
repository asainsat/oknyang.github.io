---
title: "clean architecture 4"
date: 2020-01-07
categories: architecture
---

## 12. 컴포넌트
컴포넌트는 배포 단위다. 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위다. 자바의 경우 jar 파일이 컴포넌트다. 컴포넌트가 마지막에 어떤 형태로 배포되든(.war, .jar, .dll, .exe 등등..), 잘 설계된 컴포넌트라면 반드시 독립적으로 배포 가능한, 따라서 독립적으로 개발 가능한 능력을 갖춰야 한다.

### 컴포넌트의 간략한 역사
소프트웨어 개발 초창기에는 메모리에서의 프로그램 위치와 레이아웃을 프로그래머가 직접 제어했다. 라이브러리 또한 바이너리가 아니라 소스코드 형태로 애플리케이션 코드에 직접 포함시켜 단일 프로그램으로 컴파일했다.  
이러한 형태는 애플리케이션이 사용하는 메모리가 늘어날 수록 메모리 단편화는 계속 발생할 수 밖에 없었다.

### 재배치성
메모리 단편화의 해결책은 재배치가 가능한 바이너리였다. 지능적인 로더를 사용해서 메모리에 재배치할 수 있는 형태의 바이너리를 생성하도록 컴파일러를 수정하는 것이었다. 이러한 로더를 통해 프로그래머는 오직 필요한 함수만을 로드할 수 있게 되었다.  
또한 컴파일러는 재배치 가능한 바이너리 안의 함수 이름을 메타데이터 형태로 생성하도록 수정되었다. 만약 프로그램이 라이브러리 함수를 호출한다면 컴파일러는 라이브러리 함수 이름을 외부참조로 생성했다. 반면 라이브러리 함수를 정의하는 프로그램이라면 컴파일러는 해당 이름을 외부 정의로 생성했다. 이렇게 함으로써 외부 정의를 로드할 위치가 정해지기만 하면 로더가 외부 참조를 외부 정의에 링크시킬 수 있게 된다.  
이렇게 링킹 로더가 탄생했다.

### 링커
링킹 로더의 등장으로 작은 프로그램과 비교적 작은 라이브러리를 링크할 때는 이러한 방식이 대체로 잘 동작했다. 하지만 프로그램이 점점 커지게 되자 링킹로더가 너무 느려서 참을 수 없는 지경에 다다랐다.  
마침내 로드와 링크가 두 단계로 분리되었다. 이후 프로그램이 또다시 점점 커지기 시작했고, 전체 모듈을 컴파일하고 링킹하는 시간은 또다시 늘어나기 시작했다. 1980년대 들어서 디스크는 작아지기 시작했고, 놀랄만큼 빨라졌다. 컴퓨터 메모리는 말도 안 될 정도로 저렴해져서 디스크에 저장된 많은 데이터를 모두 램에 캐싱할 수 있을 정도였다.  
1990년대 후반이 되자, 프로그래머가 프로그램을 성장시기는 속도보다 링크 시간이 줄어드는 속도가 더 빨라지기 시작했다. 소규모 작업이라면 링킹 로더 마저도 다시금 사용할 만하게 되었다.  
이렇게 공유 라이브러리 시대가 열렸고 .jar 파일도 등장하기 시작했다. 이렇게 컴포넌트 플러그인 아키텍처가 탄생했다.

### 결론
런타임에 플러그인 형태로 결합할 수 있는 동적 링크 파일이 이 책에서 말하는 소프트웨어 컴포넌트에 해당한다.

## 13. 컴포넌트 응집도
컴포넌트 응집도와 관련된 세 가지 원칙
- REP: 재사용/릴리스 등가 원칙
- CCP: 공통 폐쇄 원칙
- CRP: 공통 재사용 원칙

### REP: 재사용/릴리스 등가 원칙

```text
재사용 단위는 릴리스 단위와 같다.
```
새로운 릴리스가 나온다는 소식을 접하면, 개발자는 새 릴리스의 변경사항을 살펴보고 기존 버전을 계속 쓸지 여부를 결정하곤 한다. 따라서 릴리스 절차에는 적절한 공지와 함께 릴리스 문서 작성도 포함되어야 한다. 그래야 개발자가 충분한 정보를 바탕으로 새 릴리스를 통합할지, 한다면 언제 할지를 결정할 수 있다.  
이 원칙을 소프트웨어 설계와 아키텍처 관점에서 보면 단일 컴포넌트는 응집성 높은 클래스와 모듈들로 구성되어야 함을 뜻한다. 컴포넌트를 구성하는 모든 모듈은 서로 공유하는 중요한 테마나 목적이 있어야 한다.  
하나의 컴포넌트로 묶인 클래스와 모듈은 반드시 함께 릴리스할 수 있어야 한다. 하나의 컴포넌트로 묶인 클래스와 모듈은 버전 번호가 같아야 하며, 동일한 릴리스로 추적 관리되고, 동일한 릴리스 문서에 포함되어야 한다.

### CCP: 공통 폐쇄 원칙

```text
동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라.
서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라.
```
이 원칙은 단일 책임 원칙을 컴포넌트 관점에서 다시 쓴 것이다. SRP에서 단일 클래스는 변경의 이유가 여러 개 있어서는 안 된다고 말하듯이, 공통 폐쇄 원칙에서도 마찬가지로 단일 컴포넌트는 변경의 이유가 여러 개 있어서는 안 된다고 말한다.  
대다수의 애플리케이션에서 유지보수성은 재사용성보다 훨씬 중요하다. 애플리케이션에서 코드가 반드시 변경되어야 한다면, 이러한 변경이 여러 컴포넌트 도처에 분산되어 발생하기보다는, 차라리 변경 모두가 단일 컴포넌트에서 발생하는 편이 낫다.  
CCP는 같은 이유로 변경될 간으성이 있는 클래스는 모두 한 곳으로 묶을 것을 권한다. 물리적 또는 개념적으로 강하게 결합되어 항상 함께 변경되는 클래스들은 하나의 컴포넌트에 속해야 한다.  
이 원칙은 개방폐쇄원칙과도 밀접하게 관련되어 있다. OCP는 발생할 가능성이 있거나 과거에 발생했던 대다수의 공통적인 변경에 대해서 클래스가 닫혀있도록 설계한다.  
CCP에서는 동일한 유형의 변경에 대해 닫혀 있는 클래스들을 하나의 컴포넌트로 묶음으로써 OCP에서 얻은 교훈을 확대 적용한다.

#### SRP와의 유사성
CCP는 컴포넌트 수준의 SRP다. 두 원칙은 모두 다음과 같이 요약할 수 있다.

```text
동일한 시점에 동일한 이유로 변경되는 것들을 한데 묶어라. 
서로 다른 시점에 다른 이유로 변경되는 것들은 서로 분리하라.
```

### CRP: 공통 재사용 원칙

```text
컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라.
```
CRP에서는 같이 재사용되는 경향이 있는 클래스와 모듈들은 같은 컴포넌트에 포함해야 한다고 말한다.  
CRP는 각 컴포넌트에 어떤 클래스들을 포함시켜야 하는지를 설명해준다. 뿐만 아니라 동일한 컴포넌트로 묶어서는 안되는 클래스가 무엇인지도 말해준다.  
의존하는 컴포넌트가 있다면 해당 컴포넌트의 모든 클래스에 대해 의존함을 확실히 인지해야 한다. (단 하나의 클래스만 사용할지라도...) 바꿔 말하면, 한 컴포넌트에 속한 클래스들은 더 작게 그룹지을 수 없다. 즉, 그중 일부 클래스에만 의존하고 다른 클래스와는 독립적일 수 없음을 확실히 인지해야 한다. 그렇지 않다면 필요 이상으로 많은 컴포넌트를 재배포하느라 우리의 소중한 노력을 허비하게 된다.  
따라서 CRP는 어떤 클래스를 한데 묶어도 되는지보다는, 어떤 클래스를 한데 묶어서는 안되는지에 대해서 훨씬 더 많은 것을 이야기한다. **CRP는 강하게 결합되지 않은 클래스들은 동일한 컴포넌트에 위치시켜서는 안된다고 말한다.**

#### ISP와의 관계
CRP는 인터페이스 분리 원칙의 포괄적인 버전이다. ISP는 사용하지 않은 메서드가 있는 클래스에 의존하지 말라고 조언한다. CRP는 사용하지 않는 클래스를 가진 컴포넌트에 의존하지 말라고 조언한다. 이는 다음의 한 문장으로 요약할 수 있다.

```text
필요하지 않은 것에 의존하지 말라.
```

### 컴포넌트 응집도에 대한 균형 다이어그램
응집도에 관한 세 원칙은 서로 상충된다. REP와 CCP는 포함 원칙이다. 즉, 두 원칙은 컴포넌트를 더욱 크게 만든다. CRP는 배제 원칙이며, 컴포넌트를 더욱 작게 만든다.  
* REP와 CRP에 집중하고 CCP 포기 : 컴포넌트 변경이 너무 빈번하게 발생함.
* CRP와 CCP에 집중하고 REP 포기 : 재사용이 어려움.
* REP와 CCP에 집중하고 CRP 포기 : 불필요한 릴리스가 너무 빈번함.  

뛰어난 아키텍트라면 REP, CCP, CRP 사이의 적절한 균형점을 찾아야 한다.  
프로젝트의 컴포넌트 구조는 시간과 성숙도에 따라 변한다.

### 결론
어느 클래스들을 묶어서 컴포넌트로 만들지를 결정할 때 재사용성과 개발가능성이라는 상충하는 힘을 반드시 고려해야 한다. 이들 사이에서 애플리케이션의 요구에 맞게 균형을 잡는 일은 중요하다. 심지어 이 균형점은 거의 항상 유동적이다. 시간이 흐름에 따라 프로젝트의 초점이 개발가능성에서 재사용성으로 바뀌고, 그에 따라 컴포넌트를 구성하는 방식도 조금씩 흐트러지고 또 진화한다.

## 14. 컴포넌트 결합
