---
title: "clean architecture 4"
date: 2020-01-07
categories: architecture
---

## 12. 컴포넌트
컴포넌트는 배포 단위다. 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위다. 자바의 경우 jar 파일이 컴포넌트다. 컴포넌트가 마지막에 어떤 형태로 배포되든(.war, .jar, .dll, .exe 등등..), 잘 설계된 컴포넌트라면 반드시 독립적으로 배포 가능한, 따라서 독립적으로 개발 가능한 능력을 갖춰야 한다.

### 컴포넌트의 간략한 역사
소프트웨어 개발 초창기에는 메모리에서의 프로그램 위치와 레이아웃을 프로그래머가 직접 제어했다. 라이브러리 또한 바이너리가 아니라 소스코드 형태로 애플리케이션 코드에 직접 포함시켜 단일 프로그램으로 컴파일했다.  
이러한 형태는 애플리케이션이 사용하는 메모리가 늘어날 수록 메모리 단편화는 계속 발생할 수 밖에 없었다.

### 재배치성
메모리 단편화의 해결책은 재배치가 가능한 바이너리였다. 지능적인 로더를 사용해서 메모리에 재배치할 수 있는 형태의 바이너리를 생성하도록 컴파일러를 수정하는 것이었다. 이러한 로더를 통해 프로그래머는 오직 필요한 함수만을 로드할 수 있게 되었다.  
또한 컴파일러는 재배치 가능한 바이너리 안의 함수 이름을 메타데이터 형태로 생성하도록 수정되었다. 만약 프로그램이 라이브러리 함수를 호출한다면 컴파일러는 라이브러리 함수 이름을 외부참조로 생성했다. 반면 라이브러리 함수를 정의하는 프로그램이라면 컴파일러는 해당 이름을 외부 정의로 생성했다. 이렇게 함으로써 외부 정의를 로드할 위치가 정해지기만 하면 로더가 외부 참조를 외부 정의에 링크시킬 수 있게 된다.  
이렇게 링킹 로더가 탄생했다.

### 링커
링킹 로더의 등장으로 작은 프로그램과 비교적 작은 라이브러리를 링크할 때는 이러한 방식이 대체로 잘 동작했다. 하지만 프로그램이 점점 커지게 되자 링킹로더가 너무 느려서 참을 수 없는 지경에 다다랐다.  
마침내 로드와 링크가 두 단계로 분리되었다. 이후 프로그램이 또다시 점점 커지기 시작했고, 전체 모듈을 컴파일하고 링킹하는 시간은 또다시 늘어나기 시작했다. 1980년대 들어서 디스크는 작아지기 시작했고, 놀랄만큼 빨라졌다. 컴퓨터 메모리는 말도 안 될 정도로 저렴해져서 디스크에 저장된 많은 데이터를 모두 램에 캐싱할 수 있을 정도였다.  
1990년대 후반이 되자, 프로그래머가 프로그램을 성장시기는 속도보다 링크 시간이 줄어드는 속도가 더 빨라지기 시작했다. 소규모 작업이라면 링킹 로더 마저도 다시금 사용할 만하게 되었다.  
이렇게 공유 라이브러리 시대가 열렸고 .jar 파일도 등장하기 시작했다. 이렇게 컴포넌트 플러그인 아키텍처가 탄생했다.

### 결론
런타임에 플러그인 형태로 결합할 수 있는 동적 링크 파일이 이 책에서 말하는 소프트웨어 컴포넌트에 해당한다.

## 13. 컴포넌트 응집도
컴포넌트 응집도와 관련된 세 가지 원칙
- REP: 재사용/릴리스 등가 원칙
- CCP: 공통 폐쇄 원칙
- CRP: 공통 재사용 원칙

### REP: 재사용/릴리스 등가 원칙

```text
재사용 단위는 릴리스 단위와 같다.
```
새로운 릴리스가 나온다는 소식을 접하면, 개발자는 새 릴리스의 변경사항을 살펴보고 기존 버전을 계속 쓸지 여부를 결정하곤 한다. 따라서 릴리스 절차에는 적절한 공지와 함께 릴리스 문서 작성도 포함되어야 한다. 그래야 개발자가 충분한 정보를 바탕으로 새 릴리스를 통합할지, 한다면 언제 할지를 결정할 수 있다.  
이 원칙을 소프트웨어 설계와 아키텍처 관점에서 보면 단일 컴포넌트는 응집성 높은 클래스와 모듈들로 구성되어야 함을 뜻한다. 컴포넌트를 구성하는 모든 모듈은 서로 공유하는 중요한 테마나 목적이 있어야 한다.  
하나의 컴포넌트로 묶인 클래스와 모듈은 반드시 함께 릴리스할 수 있어야 한다. 하나의 컴포넌트로 묶인 클래스와 모듈은 버전 번호가 같아야 하며, 동일한 릴리스로 추적 관리되고, 동일한 릴리스 문서에 포함되어야 한다.

### CCP: 공통 폐쇄 원칙

```text
동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라.
서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라.
```
이 원칙은 단일 책임 원칙을 컴포넌트 관점에서 다시 쓴 것이다. SRP에서 단일 클래스는 변경의 이유가 여러 개 있어서는 안 된다고 말하듯이, 공통 폐쇄 원칙에서도 마찬가지로 단일 컴포넌트는 변경의 이유가 여러 개 있어서는 안 된다고 말한다.  
대다수의 애플리케이션에서 유지보수성은 재사용성보다 훨씬 중요하다. 애플리케이션에서 코드가 반드시 변경되어야 한다면, 이러한 변경이 여러 컴포넌트 도처에 분산되어 발생하기보다는, 차라리 변경 모두가 단일 컴포넌트에서 발생하는 편이 낫다.  
CCP는 같은 이유로 변경될 간으성이 있는 클래스는 모두 한 곳으로 묶을 것을 권한다. 물리적 또는 개념적으로 강하게 결합되어 항상 함께 변경되는 클래스들은 하나의 컴포넌트에 속해야 한다.  
이 원칙은 개방폐쇄원칙과도 밀접하게 관련되어 있다. OCP는 발생할 가능성이 있거나 과거에 발생했던 대다수의 공통적인 변경에 대해서 클래스가 닫혀있도록 설계한다.  
CCP에서는 동일한 유형의 변경에 대해 닫혀 있는 클래스들을 하나의 컴포넌트로 묶음으로써 OCP에서 얻은 교훈을 확대 적용한다.

#### SRP와의 유사성
CCP는 컴포넌트 수준의 SRP다. 두 원칙은 모두 다음과 같이 요약할 수 있다.

```text
동일한 시점에 동일한 이유로 변경되는 것들을 한데 묶어라. 
서로 다른 시점에 다른 이유로 변경되는 것들은 서로 분리하라.
```

### CRP: 공통 재사용 원칙


