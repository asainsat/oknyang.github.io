---
title: "clean architecture 4"
date: 2020-01-07
categories: architecture
---

## 12. 컴포넌트
컴포넌트는 배포 단위다. 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위다. 자바의 경우 jar 파일이 컴포넌트다. 컴포넌트가 마지막에 어떤 형태로 배포되든(.war, .jar, .dll, .exe 등등..), 잘 설계된 컴포넌트라면 반드시 독립적으로 배포 가능한, 따라서 독립적으로 개발 가능한 능력을 갖춰야 한다.

### 컴포넌트의 간략한 역사
소프트웨어 개발 초창기에는 메모리에서의 프로그램 위치와 레이아웃을 프로그래머가 직접 제어했다. 라이브러리 또한 바이너리가 아니라 소스코드 형태로 애플리케이션 코드에 직접 포함시켜 단일 프로그램으로 컴파일했다.  
이러한 형태는 애플리케이션이 사용하는 메모리가 늘어날 수록 메모리 단편화는 계속 발생할 수 밖에 없었다.

### 재배치성
메모리 단편화의 해결책은 재배치가 가능한 바이너리였다. 지능적인 로더를 사용해서 메모리에 재배치할 수 있는 형태의 바이너리를 생성하도록 컴파일러를 수정하는 것이었다. 이러한 로더를 통해 프로그래머는 오직 필요한 함수만을 로드할 수 있게 되었다.  
또한 컴파일러는 재배치 가능한 바이너리 안의 함수 이름을 메타데이터 형태로 생성하도록 수정되었다. 만약 프로그램이 라이브러리 함수를 호출한다면 컴파일러는 라이브러리 함수 이름을 외부참조로 생성했다. 반면 라이브러리 함수를 정의하는 프로그램이라면 컴파일러는 해당 이름을 외부 정의로 생성했다. 이렇게 함으로써 외부 정의를 로드할 위치가 정해지기만 하면 로더가 외부 참조를 외부 정의에 링크시킬 수 있게 된다.  
이렇게 링킹 로더가 탄생했다.

### 링커
링킹 로더의 등장으로 작은 프로그램과 비교적 작은 라이브러리를 링크할 때는 이러한 방식이 대체로 잘 동작했다. 하지만 프로그램이 점점 커지게 되자 링킹로더가 너무 느려서 참을 수 없는 지경에 다다랐다.  
마침내 로드와 링크가 두 단계로 분리되었다. 이후 프로그램이 또다시 점점 커지기 시작했고, 전체 모듈을 컴파일하고 링킹하는 시간은 또다시 늘어나기 시작했다. 1980년대 들어서 디스크는 작아지기 시작했고, 놀랄만큼 빨라졌다. 컴퓨터 메모리는 말도 안 될 정도로 저렴해져서 디스크에 저장된 많은 데이터를 모두 램에 캐싱할 수 있을 정도였다.  
1990년대 후반이 되자, 프로그래머가 프로그램을 성장시기는 속도보다 링크 시간이 줄어드는 속도가 더 빨라지기 시작했다. 소규모 작업이라면 링킹 로더 마저도 다시금 사용할 만하게 되었다.  
이렇게 공유 라이브러리 시대가 열렸고 .jar 파일도 등장하기 시작했다. 이렇게 컴포넌트 플러그인 아키텍처가 탄생했다.

### 결론
런타임에 플러그인 형태로 결합할 수 있는 동적 링크 파일이 이 책에서 말하는 소프트웨어 컴포넌트에 해당한다.

## 13. 컴포넌트 응집도
컴포넌트 응집도와 관련된 세 가지 원칙
- REP: 재사용/릴리스 등가 원칙
- CCP: 공통 폐쇄 원칙
- CRP: 공통 재사용 원칙

### REP: 재사용/릴리스 등가 원칙

```text
재사용 단위는 릴리스 단위와 같다.
```
새로운 릴리스가 나온다는 소식을 접하면, 개발자는 새 릴리스의 변경사항을 살펴보고 기존 버전을 계속 쓸지 여부를 결정하곤 한다. 따라서 릴리스 절차에는 적절한 공지와 함께 릴리스 문서 작성도 포함되어야 한다. 그래야 개발자가 충분한 정보를 바탕으로 새 릴리스를 통합할지, 한다면 언제 할지를 결정할 수 있다.  
이 원칙을 소프트웨어 설계와 아키텍처 관점에서 보면 단일 컴포넌트는 응집성 높은 클래스와 모듈들로 구성되어야 함을 뜻한다. 컴포넌트를 구성하는 모든 모듈은 서로 공유하는 중요한 테마나 목적이 있어야 한다.  
하나의 컴포넌트로 묶인 클래스와 모듈은 반드시 함께 릴리스할 수 있어야 한다. 하나의 컴포넌트로 묶인 클래스와 모듈은 버전 번호가 같아야 하며, 동일한 릴리스로 추적 관리되고, 동일한 릴리스 문서에 포함되어야 한다.

### CCP: 공통 폐쇄 원칙

```text
동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라.
서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라.
```
이 원칙은 단일 책임 원칙을 컴포넌트 관점에서 다시 쓴 것이다. SRP에서 단일 클래스는 변경의 이유가 여러 개 있어서는 안 된다고 말하듯이, 공통 폐쇄 원칙에서도 마찬가지로 단일 컴포넌트는 변경의 이유가 여러 개 있어서는 안 된다고 말한다.  
대다수의 애플리케이션에서 유지보수성은 재사용성보다 훨씬 중요하다. 애플리케이션에서 코드가 반드시 변경되어야 한다면, 이러한 변경이 여러 컴포넌트 도처에 분산되어 발생하기보다는, 차라리 변경 모두가 단일 컴포넌트에서 발생하는 편이 낫다.  
CCP는 같은 이유로 변경될 간으성이 있는 클래스는 모두 한 곳으로 묶을 것을 권한다. 물리적 또는 개념적으로 강하게 결합되어 항상 함께 변경되는 클래스들은 하나의 컴포넌트에 속해야 한다.  
이 원칙은 개방폐쇄원칙과도 밀접하게 관련되어 있다. OCP는 발생할 가능성이 있거나 과거에 발생했던 대다수의 공통적인 변경에 대해서 클래스가 닫혀있도록 설계한다.  
CCP에서는 동일한 유형의 변경에 대해 닫혀 있는 클래스들을 하나의 컴포넌트로 묶음으로써 OCP에서 얻은 교훈을 확대 적용한다.

#### SRP와의 유사성
CCP는 컴포넌트 수준의 SRP다. 두 원칙은 모두 다음과 같이 요약할 수 있다.

```text
동일한 시점에 동일한 이유로 변경되는 것들을 한데 묶어라. 
서로 다른 시점에 다른 이유로 변경되는 것들은 서로 분리하라.
```

### CRP: 공통 재사용 원칙

```text
컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라.
```
CRP에서는 같이 재사용되는 경향이 있는 클래스와 모듈들은 같은 컴포넌트에 포함해야 한다고 말한다.  
CRP는 각 컴포넌트에 어떤 클래스들을 포함시켜야 하는지를 설명해준다. 뿐만 아니라 동일한 컴포넌트로 묶어서는 안되는 클래스가 무엇인지도 말해준다.  
의존하는 컴포넌트가 있다면 해당 컴포넌트의 모든 클래스에 대해 의존함을 확실히 인지해야 한다. (단 하나의 클래스만 사용할지라도...) 바꿔 말하면, 한 컴포넌트에 속한 클래스들은 더 작게 그룹지을 수 없다. 즉, 그중 일부 클래스에만 의존하고 다른 클래스와는 독립적일 수 없음을 확실히 인지해야 한다. 그렇지 않다면 필요 이상으로 많은 컴포넌트를 재배포하느라 우리의 소중한 노력을 허비하게 된다.  
따라서 CRP는 어떤 클래스를 한데 묶어도 되는지보다는, 어떤 클래스를 한데 묶어서는 안되는지에 대해서 훨씬 더 많은 것을 이야기한다. **CRP는 강하게 결합되지 않은 클래스들은 동일한 컴포넌트에 위치시켜서는 안된다고 말한다.**

#### ISP와의 관계
CRP는 인터페이스 분리 원칙의 포괄적인 버전이다. ISP는 사용하지 않은 메서드가 있는 클래스에 의존하지 말라고 조언한다. CRP는 사용하지 않는 클래스를 가진 컴포넌트에 의존하지 말라고 조언한다. 이는 다음의 한 문장으로 요약할 수 있다.

```text
필요하지 않은 것에 의존하지 말라.
```

### 컴포넌트 응집도에 대한 균형 다이어그램
응집도에 관한 세 원칙은 서로 상충된다. REP와 CCP는 포함 원칙이다. 즉, 두 원칙은 컴포넌트를 더욱 크게 만든다. CRP는 배제 원칙이며, 컴포넌트를 더욱 작게 만든다.  
* REP와 CRP에 집중하고 CCP 포기 : 컴포넌트 변경이 너무 빈번하게 발생함.
* CRP와 CCP에 집중하고 REP 포기 : 재사용이 어려움.
* REP와 CCP에 집중하고 CRP 포기 : 불필요한 릴리스가 너무 빈번함.  

뛰어난 아키텍트라면 REP, CCP, CRP 사이의 적절한 균형점을 찾아야 한다.  
프로젝트의 컴포넌트 구조는 시간과 성숙도에 따라 변한다.

### 결론
어느 클래스들을 묶어서 컴포넌트로 만들지를 결정할 때 재사용성과 개발가능성이라는 상충하는 힘을 반드시 고려해야 한다. 이들 사이에서 애플리케이션의 요구에 맞게 균형을 잡는 일은 중요하다. 심지어 이 균형점은 거의 항상 유동적이다. 시간이 흐름에 따라 프로젝트의 초점이 개발가능성에서 재사용성으로 바뀌고, 그에 따라 컴포넌트를 구성하는 방식도 조금씩 흐트러지고 또 진화한다.

## 14. 컴포넌트 결합
### ADP: 의존성 비순환 원칙
```text
컴포넌트 의존성 그래프에 순환이 있어서는 안된다.
```
동일한 소스파일을 여러명의 개발자가 수정하는 환경에서 발생하는 문제를 '숙취 증후군'이라고 한다. 이 문제의 해결책으로 두 가지 방법이 발전되어 왔는데, '주 단위 빌드'와 '의존성 비순환 원칙'이다.

#### 주 단위 빌드
주 단위 빌드는 중간 규모의 프로젝트에서는 흔하게 사용된다.  
모든 개발자는 일주일의 첫 4일 동안은 서로를 신경쓰지 않는다. 개발자는 모두 코드를 개인적으로 복사하여 작업하며, 전체적인 기준에서 작업을 어떻게 통합할지는 걱정하지 않는다. 이후 금요일이 되면 변경된 코드를 모두 통합하여 시스템을 빌드한다.  
프로젝트가 커지면 프로젝트 통합은 금요일 하루 만에 끝마치는게 불가능해 진다. 개발보다 통합에 드는 시간이 늘어나면서 팀의 효율성도 서서히 나빠진다.

#### 순환 의존성 제거하기
개발 환경을 릴리스 가능한 컴포넌트 단위로 분리한다. 이를 통해 컴포넌트는 개별 개발자 또는 단일 개발팀이 책임질 수 있는 작업 단위가 된다. 개발자가 해당 컴포넌트가 동작하도록 만든 후, 해당 컴포넌트를 릴리스하여 다른 개발자가 사용할수 있도록 만든다. 담당 개발자는 이 컴포넌트에 릴리스 번호를 부여하고, 다른 팀에서 사용할 수 있는 디렉터리로 이동시킨다. 그런 다음 개발자는 자신만의 공간에서 해당 컴포넌트를 지속적으로 수정한다. 나머지 개발자는 릴리스된 버전을 사용한다.  
이 같은 작업 절차는 단순하며 합리적이어서 널리 사용되는 방식이다. 하지만 이 절차가 성공적으로 동작하려면 컴포넌트 사이의 의존성 구조를 반드시 관리해야 한다. 의존성 구조에 순환이 있어서는 안 된다. 의존성 구조에 순환이 생기면 '숙취 증후군'을 피해 갈 수 없다.  

#### 순환이 컴포넌트 의존성 그래프에 미치는 영향
컴포넌트간 순환이 생기면 컴포넌트를 분리하기가 상당히 어려워진다. 뿐만 아니라 의존성 그래프에 순환이 생기면 컴포넌트를 어떤 순서로 빌드해야 올바를지 파악하기가 상당히 힘들어진다. 사실 순환이 생기면 올바른 순서라는 것 자체가 없을 수 있다. 특히 자바와 같이 컴파일된 바이너리 파일에서 선언문을 읽어 들이는 언어라면 끔찍한 문제가 일어날 수도 있다.

#### 순환 끊기
컴포넌트 사이의 순환을 끊기 위한 주요 메커니즘 2가지
1. 의존성 역전 원칙을 적용한다. 클래스 A가 필요로 하는 메서드를 제공하는 인터페이스를 생성하고, 이 인터페이스는 A가 속한 컴포넌트에 위치시킨다. 다른 컴포넌트에 위치한 B 클래스에서는 이 인터페이스를 상속받는다.
2. 컴포넌트 A와 B가 모두 의존하는 새로운 컴포넌트를 만든다. 그리고 두 컴포넌트가 모두 의존하는 클래스들을 새로운 컴포넌트로 이동시킨다.

#### 흐트러짐
두 번째 해결책에서 시사하는 바는 요구사항이 변경되면 컴포넌트 구조도 변경될 수 있다는 사실이다. 실제로 애플리케이션이 성장함에 따라 컴포넌트 의존성 구조는 서서히 흐트러지며 또 성장한다. 따라서 의존성 구조에 순환이 발생하는지를 항상 관찰해야 한다. 순환이 발생하면 어떤 식으로든 끊어야 한다. 이 말은 때론 새로운 컴포넌트를 생성하거나 의존성 구조가 더 커질 수도 있음을 의미한다.

### 하향식(top-down) 설계
컴포넌트 구조는 하향식을 설계될 수 없다. 컴포넌트는 시스템에서 가장 먼저 설계할 수 있는 대상이 아니며, 오히려 시스템이 성장하고 변경될 때 함께 진화한다.  
사실 컴포넌트 의존성 다이어그램은 애플리케이션으 기능을 기술하는 일과는 거의 관련이 없다. 오히려 컴포넌트 의존성 다이어그램은 애플리케이션의 빌드 가능성과 유지보수성을 보여주는 지도와 같다. 바로 이러한 이유 때문에 컴포넌트 구조는 프로젝트 초기에 설계할 수 없다. 하지만 구현과 설계가 이뤄지는 프로젝트 초기에 모듈들이 점차 쌓이게 되면 '숙취증후군'을 겪지 않고 프로젝트를 개발하기 위해서 의존성 관리에 대한 요구가 점차 늘어나게 된다. 뿐만 아니라 변경되는 범위가 시스템의 가능한 한 작은 일부로 한정되기를 원한다. 그래서 결국 단일 책임 원칙과 공통 폐쇄 원칙에 관심을 갖기 시작하고, 이를 적용해 함께 변경되는 클래스는 같은 위치에 배치되도록 만든다.  
애플리케이션이 계속 성장함에 따라 재사용 가능한 요소를 만드는 일에 관심을 기울이게 되고, 이 시점이 되면 컴포넌트를 조합하는 과정에 공통 재사용 원칙이 영향을 미치게 된다. 결국 순환이 발생하면 ADP가 적용되고, 컴포넌트 의존성 그래프는 조금씩 흐트러지고 또 성장한다.  
컴포넌트 의존성 구조는 시스템의 논리적 설계에 발맞춰 성장하며 진화해야 한다.

### SDP: 안정된 의존성 원칙
```text
안정성의 방향으로(더 안정된 쪽에) 의존하라.
```
변경이 쉽지 않은 컴포넌트가 변동이 예상되는 컴포넌트에 의존하게 만들어서는 절대로 안된다. 한번 의존하게 되면 변동성이 큰 컴포넌트도 결국 변경이 어려워진다.

#### 안정성
안정성은 변화가 발생하는 빈도와는 직접적인 관련이 없다. 안정적이라는 말을 웹스터 사전에서는 '쉽게 움직이지 않는'이라고 정의한다.  
소프트웨어 컴포넌트를 변경하기 어렵게 만드는 확실한 방법 하나는 수많은 다른 컴포넌트가 해당 컴포넌트에 의존하게 만드는 것이다. 컴포넌트 안쪽으로 들어오는 의존성이 많아지면 상당히 안정적이라 볼 수 있는데, 사소한 변경이라도 의존하는 모든 컴포넌트를 만족시키면서 변경하려면 상당한 노력이 들기 때문이다.  
A, B, C 컴포넌트가 X 컴포넌트에 의존하고 있다면 X는 안정된 컴포넌트라고 할 수 있고 이 경우 X는 세 컴포넌트를 책임진다 라고 말한다. 반대로 X는 어디에도 의존하지 않으므로 X가 변경되도록 만들 수 있는 외적이 영향이 전혀 없다. 이 경우 X는 독립적이다라고 말한다.
반대로 Y컴포넌트가 A, B, C 컴포넌트에 의존하고 있다면, Y는 상당히 불안정한 컴포넌트다. 어떤 컴포넌트도 Y에 의존하지 않으므로 책임성이 없다고 할 수 있다. 또한 Y는 세 개의 컴포넌트에 의존하므로 변경이 발생할 수 있는 외부 요인이 세 가지다. 이 경우 Y는 의존적이라고 말한다.

#### 안정성 지표
컴포넌트로 들어오고 나가는 의존성 개수를 세어보고, 이 숫자를 통해 컴포넌트가 위치상 어느 정도의 안정성을 가지는지 계산할 수 있다.

* Fan-in : 안으로 들어오는 의존성
* Fan-out : 바깥을 나가는 의존성
* I(불안정성) : I = Fan-out / (Fan-in + fan-out). I=0이면 최고로 안정된 컴포넌트. I=1이면 최고로 불안정한 컴포넌트.

SDP에서 컴포넌트의 I 지표는 그 컴포넌트가 의존하는 다른 컴포넌트들의 I보다 커야 한다고 말한다. 즉, 의존성 방향으로 갈수록 I 지표 값이 감소해야 한다.

#### 모든 컴포넌트가 안정적이어야 하는 것은 아니다

### SAP: 안정된 추상화 원칙
```text
컴포넌트는 안정된 정도만큼만 추상화되어야 한다.
```
안정된 추상화 원칙은 안정성과 추상화 정도 사이의 관계를 정의한다. 이 원칙은 한편으로는 안정된 컴포넌트는 추상 컴포넌트여야 하며, 이를 통해 안정성이 컴포넌트를 확장하는 일을 방해해서는 안된다고 말한다. 다른 한편으로는 불안정한 컴포넌트는 반드시 구체 컴포넌트여야 한다고 말한다.  
SAP와 SDP를 결합하면 컴포넌트에 대한 DIP나 마찬가지가 된다. SDP에서는 의존성이 반드시 안정성의 방향으로 향해야 한다고 말하며, SAP에서는 안정성이 결국 추상화를 의미한다고 말하기 때문이다. 따라서 의존성은 추상화의 방향으로 향하게 된다.

#### 추상화 정도 측정하기
* Nc : 컴포넌트의 클래스 개수
* Na : 컴포넌트의 추상 클래스와 인터페이스의 개수
* A : 추상화 정도. A = Na / Nc

### 결론
의존성 관리 지표는 설계의 의존성과 추상화 정도가 '훌륭한' 패턴이라고 생각하는 수준에 얼마나 잘 부합하는지를 측정한다. 지표는 그저 임의로 결정된 표준을 기초로 한 측정값에 지나지 않지만, 이들 지표로부터 무언가 유용한 것을 찾을 수 있기를 바란다.
