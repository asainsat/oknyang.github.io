---
title: "clean architecture 3"
date: 2020-01-06
categories: architecture
---

```text
SOLID
SRP: 단일 책임 원칙
      각 소프트웨어 모듈은 변경의 이유가 하나, 단 하나여야만 한다.
OCP: 개방-페쇄 원칙
      기존 코드를 수정하기보다는 반드시 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 설계해야 한다.
LSP: 리스코프 치환 원칙
      상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들 수 있으려면, 이들 구성요소는 반드시 서로 치환 가능해야 한다.
ISP: 인터페이스 분리 원칙
      소프트웨어 설계자는 사용하지 않은 것에 의존하지 않아야 한다.
DIP: 의존성 역전 원칙
      고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대 의존해서는 안된다. 대신 세부사항이 정책에 의존해야 한다.
```

## 7. SRP: 단일 책임 원칙
SOLID 원칙 중에서 그 의미가 가장 잘 전달되지 못한 원칙은 바로 단일 책임 원칙이다. 프로그래머가 이 원칙의 이름을 듣는다면 모든 모듈이 단 하나의 일만 해야 한다는 의미로 받아들이기 쉽다.  
단 하나의 일만 해야 한다는 원칙은 사실 따로 있다. 그것은 바로 함수는 반드시 하나의, 단 하나의 일만 해야 한다는 원칙이다. 이 원칙은 커다란 함수를 작은 함수들로 리팩터링하는 더 저수준에서 사용된다. 하지만 이 원칙은 SOLID 원칙이 아니며, SRP도 아니다.  

SRP는 아래와 같이 정의된다.

```text
"하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다."
```

모듈의 가장 단순한 정의는 소스파일이다. 또는 단순히 함수와 데이터 구조로 구성된 응집된 집합이라고 할 수 있다.  
'응집된'이라는 단어가 SRP를 암시한다. 단일 액터를 책임지는 코드를 함께 묶어주는 힘이 바로 응집성이다.  

### SRP를 위반한 경우의 해결책
하나의 클래스에 여러 액터에 대한 책임이 섞여있을 경우 해결책은 다양하지만, 모두 다 메서드를 각기 다른 클래스로 이동 시키는 방식이다. 각 액터에 대한 메소드를 각각의 클래스로 분리한 후, 퍼사드 패턴을 적용해 클래스 객체를 생성하고, 해당 객체로 위임하는 역할을 하는 클래스를 만든다.

### 결론
단일 책임 원칙은 메서드와 클래스 수준의 원칙이다. 하지만 이보다 상위의 두 수준에서도 다른 형태로 다시 등장한다. 컴포넌트 수준에서는 공통 폐쇄 원칙이 된다. 아키텍처 수준에서는 아키텍처 경계의 생성을 책임지는 변경의 축이 된다.

## 8. OCP: 개방-폐쇄 원칙
