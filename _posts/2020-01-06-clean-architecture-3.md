---
title: "clean architecture 3"
date: 2020-01-06
categories: architecture
---

```text
SOLID
SRP: 단일 책임 원칙
      각 소프트웨어 모듈은 변경의 이유가 하나, 단 하나여야만 한다.
OCP: 개방-페쇄 원칙
      기존 코드를 수정하기보다는 반드시 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 설계해야 한다.
LSP: 리스코프 치환 원칙
      상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들 수 있으려면, 이들 구성요소는 반드시 서로 치환 가능해야 한다.
ISP: 인터페이스 분리 원칙
      소프트웨어 설계자는 사용하지 않은 것에 의존하지 않아야 한다.
DIP: 의존성 역전 원칙
      고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대 의존해서는 안된다. 대신 세부사항이 정책에 의존해야 한다.
```

## 7. SRP: 단일 책임 원칙
SOLID 원칙 중에서 그 의미가 가장 잘 전달되지 못한 원칙은 바로 단일 책임 원칙이다. 프로그래머가 이 원칙의 이름을 듣는다면 모든 모듈이 단 하나의 일만 해야 한다는 의미로 받아들이기 쉽다.  
단 하나의 일만 해야 한다는 원칙은 사실 따로 있다. 그것은 바로 함수는 반드시 하나의, 단 하나의 일만 해야 한다는 원칙이다. 이 원칙은 커다란 함수를 작은 함수들로 리팩터링하는 더 저수준에서 사용된다. 하지만 이 원칙은 SOLID 원칙이 아니며, SRP도 아니다.  

SRP는 아래와 같이 정의된다.

```text
"하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다."
```

모듈의 가장 단순한 정의는 소스파일이다. 또는 단순히 함수와 데이터 구조로 구성된 응집된 집합이라고 할 수 있다.  
'응집된'이라는 단어가 SRP를 암시한다. 단일 액터를 책임지는 코드를 함께 묶어주는 힘이 바로 응집성이다.  

### SRP를 위반한 경우의 해결책
하나의 클래스에 여러 액터에 대한 책임이 섞여있을 경우 해결책은 다양하지만, 모두 다 메서드를 각기 다른 클래스로 이동 시키는 방식이다. 각 액터에 대한 메소드를 각각의 클래스로 분리한 후, 퍼사드 패턴을 적용해 클래스 객체를 생성하고, 해당 객체로 위임하는 역할을 하는 클래스를 만든다.

### 결론
단일 책임 원칙은 메서드와 클래스 수준의 원칙이다. 하지만 이보다 상위의 두 수준에서도 다른 형태로 다시 등장한다. 컴포넌트 수준에서는 공통 폐쇄 원칙이 된다. 아키텍처 수준에서는 아키텍처 경계의 생성을 책임지는 변경의 축이 된다.

## 8. OCP: 개방-폐쇄 원칙
```text
소프트웨어 개체는 확장에는 열려있어야 하고, 변경에는 닫혀 있어야 한다.
```
소프트웨어 설계를 공부하기 시작한지 얼마 안 된 사람들 대다수는 OCP를 클래스와 모듈을 설계할 때 도움되는 원칙이라고 알고 있다. 
하지만 아키텍처 컴포넌트 수준에서 OCP를 고려할 때 훨씬 중요한 의미를 가진다.  
사고 실험을 해 보면 이 점이 분명해 진다.

### 사고실험
A 컴포넌트에서 발생한 변경으로부터 B 컴포넌트를 보호하려면 반드시 A 컴포넌트가 B 컴포넌트에 의존해야 한다.  
애플리케이션에서 가장 높은 수준의 정책을 포함하는 핵심 컴포넌트는 OCP를 가장 잘 준수할 수 있는 곳에 위치해야 한다. (다른 어떤 컴포넌트의 변경도 핵심 컴포넌트에 영향을 주어서는 안된다.)  
보호의 계층 구조가 '수준(level)'이라는 개념을 바탕으로 생성되고, 이것이 바로 아키텍처 수준에서 OCP가 동작하는 방식이다. 아키텍트는 기능이 어떻게, 왜, 언제 발생하는지에 따라서 기능을 분리하고, 분리한 기능을 컴포넌트의 계층구조로 조직화 한다. 컴포넌트 계층구조를 이와 같이 조직화 하면 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있다.

### 방향성 제어
의존성을 역전시키기 위해 인터페이스를 활용할 수 있다. (A 컴포넌트를 보호하기 위해 A 컴포넌트가 A.C 인터페이스를 의존하고, B 컴포넌트가 A.C 인터페이스를 구현하거나 상속하는 구조. 즉, 의존성은 A -> A.C <- B 가 된다. 만약 인터페이스 A.C가 없었다면 의존성이 A 컴포넌트에서 바로 B 컴포넌트로 향하게 되어 OCP 원칙에 취약하게 된다.)

### 정보 은닉
추이 종속성을 막기 위해서도 인터페이스를 활용할 수 있다. (A 컴포넌트가 B 컴포넌트의 C 인터페이스에 의존하는 경우. 이 경우 의존성은 A -> B.C <- B 가 되며, A 컴포넌트에서는 B.C 이외에 다른 클래스들에 대해 알 수 없다. B.C 인터페이스가 없었다면 A 컴포넌트는 B 컴포넌트 내부의 클래스에 대해 추이 종속성을 가지게 된다.)
추이 종속성을 가지게 되면, 소프트웨어 엔티티는 '자신이 직접 사용하지 않는 요소에는 절대로 의존해서는 안 된다'는 소프트웨어 원칙을 위반하게 된다.

```text
추이종속성
클래스 A가 클래스 B에 의존하고, 다시 클래스 B가 클래스 C에 의존한다면,
클래스 A는 클래스 C에 의존하게 된다. 이를 추이 종속성이라고 부르며, 
클래스 이외의 소프트웨어의 모든 엔티티(패키지, 컴포넌트 등)에도 동일하게 적용된다.
```

### 결론
OCP는 시스템의 아키텍처를 떠받치는 원동력 중 하나다. OCP의 목표는 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는 데 있다. 이러한 목표를 달성하려면 시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발ㄹ생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조가 만들어지도록 해야 한다.

## 9. LSP: 리스코프 치환 원칙
```text
S 타입의 객체 o1 각각에 대응하는 T 타입 객체 o2가 있고, 
T 타입을 이용해서 정의한 모든 프로그램 P에서 o2의 자리에 o1을 치환하더라도 P의 행위가 변하지 않는다면, 
S는 T의 하위 타입이다.
```

### 상속을 사용하도록 가이드 하기
License라는 클래스는 calcFee()라는 메서드를 가지며, Billing 애플리케이션에서 이 메서드를 호출한다. License에는 PersonalLicense와 BusinessLicense라는 두 가지 '하위 타입'이 존재한다. 이들 두 하위 타입은 서로 다른 알고리즘을 이용해서 라이선스 비용을 계산한다. 이 설계는 LSP를 준수하는데, Billing 애플리케이션의 행위가 License 하위 타입 중 무엇을 사용하는지에 전혀 의존하지 않기 때문이다. 이들 하위 타입은 모두 License 타입을 치환할 수 있다.

### 정사각형 / 직사각형 문제
LSP를 위반하는 전형적인 문제로는 유명한 정사각형/직사각형 문제가 있다.  
Rectangle 클래스가 있고, 하위 타입으로 Square 클래스가 있다. User는 Rectangle을 호출한다.  
이 예제에서 Square는 Rectangle의 하위타입으로는 적합하지 않은데, Rectangle의 높이와 너비는 서로 독립적으로 변경될 수 있는 반면, Square의 높이와 너비는 반드시 함께 변경되기 때문이다. User는 대화하고 있는 상대가 Rectangle이라고 생각하므로 혼동이 생길 수 있다.  
이런 형태의 LSP 위반을 막기 위한 유일한 방법은 Rectangle이 실제로는 Square인지를 검사하는 메커니즘을 User에 추가하는 것이다. 하지만 이렇게 하면 User의 행위가 사용하는 타입에 의존하게 되므로, 결국 타입을 서로 치환할 수 없게 된다.

### LSP와 아키텍처
LSP는 상속 뿐 아니라 인터페이스와 구현체에도 적용되는 광범위한 소프트웨어 설계 원칙으로 변모해 왔다.  
아키텍처 관점에서 LSP를 이해하는 최선의 방법은 이 원칙을 어겼을 때 시스템 아키텍처에서 무슨 일이 일어나는지 관찰하는 것이다.

### 결론
LSP는 아키텍처 수준까지 확장할 수 있고, 반드시 확장해야만 한다. 치환 가능성을 조금이라도 위배하면 시스템 아키텍처가 오염되어 상당량의 별도 메커니즘을 추가해야 할 수 있기 때문이다.

## 10. ISP: 인터페이스 분리 원칙
User1, 2, 3 클래스가 있고, 이 사용자들은 OPS 클래스의 오퍼레이션을 사용한다. User1은 op1만, User2는 op2, User3은 op3만 사용한다고 가정해 보자. 그리고 OPS가 정적 타입 언어로 작성된 클래스라고 해보자. 이 경우 User1에서는. op2와 op3을 전혀 사용하지 않음에도 User1의 소스코드는 이 두 메서드에 의존하게 된다. 이러한 의존성으로 인해 OPS클래스에서 op2의 소스코드가 변경되면 User1도 다시 컴파일한 후 새로 배포해야 한다.  
이러한 문제는 오퍼레이션을 인터페이스 단위로 분리하여 해결할 수 있다.

### ISP와 언어
정적 타입 언어는 사용자가 import, use 또는 include 같은 타입 선언문을 사용하도록 강제한다. 이러한 선언문으로 인해 소스코드 의존성이 발생하고, 이로인해 재컴파일 또는 재배포가 강제되는 상황이 무조건 초래된다.  
루비나 파이썬 같은 동적 타입 언어에서는 소스코드에 이러한 선언문이 존재하지 않는다. 따라서 소스 코드 의존성이 아예 없으며, 결국 재컴파일과 재배포가 필요없다. 동적 타입 언어를 사용하면 정적 타입 언어를 사용할 때보다 유연하며 결합도가 낮은 시스템을 만들 수 있는 이유는 바로 이 때문이다.(사실 정적 언어라도 종류에 따라 영향받는 정도가 다름)  
이러한 사실로 인해 ISP를 아키텍처가 아니라, 언어와 관련된 문제라고 결론내릴 여지가 있다.

### ISP와 아키텍처
일반적으로, 필요 이상으로 많은 걸 포함하는 모듈에 의존하는 것은 해로운 일이다. 소스 코드 의존성의 경우 이는 분명한 사실인데, 불필요한 재컴파일과 재배포를 강제하기 때문이다. 하지만 더 고수준인 아키텍처 수준에서도 마찬가지 상황이 발생한다.

### 결론
불필요한 짐을 실은 무언가에 의존하면 예상치도 못한 문제에 빠진다.

## 11. DIP: 의존성 역전 원칙
의존성 역전 원칙에서 말하는 '유연성이 극대화된 시스템'이란 소스코드 의존성이 추상에 의존하며 구체에는 의존하지 않는 시스템이다.  
DIP를 논할 때 운영체제나 플랫폼 같이 안정성이 보장된 환경에 대해서는 무시하는 편이다. 변경되지 않는다면 의존할 수 있다는 사실을 이미 알고있기 때문이다.  
의존하지 않도록 피하고자 하는 것은 변동성이 큰 구체적인 요소이며, 이 구체적인 요소는 개발중이라 자주 변경될 수 밖에 없는 모듈들이다.

### 안정된 추상화
안정된 소프트웨어 아키텍처란 변동성이 큰 구현체에 의존하는 일은 지양하고, 안정된 추상 인터페이스를 선호하는 아키텍처라는 뜻이다. 이 원칙을 위한 코딩 실천법은 아래와 같다.  

#### 변동성이 큰 구체 클래스를 참조하지 말라.
대신 추상 인터페이스를 참조하라.  
이 규칙은 객체 생성 방식을 강하게 제약하며, 일반적으로 추상 팩토리를 사용하도록 강제한다.

#### 변동성이 큰 구체 클래스로부터 파생하지 말라.
정적 타입 언어에서 상속은 소스 코드에 존재하는 모든 관계 중에서 가장 강력한 동시에 뻣뻣해서 변경하기 어렵다. 따라서 상속은 아주 신중하게 사용해야 한다.

#### 구체 함수를 오버라이드 하지 말라.
대체로 구체 함수는 소스 코드 의존성을 필요로 한다. 따라서 구체 함수를 오버라이드 하면 이러한 의존성을 제거할 수 없게 되며, 실제로는 그 의존성을 상속하게 된다. 차라리 추상 함수로 선언하고 구현체들에서 각자의 용도에 맞게 구현해야 한다.

#### 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라.

### 팩토리
위와 같은 규칙들을 준수하려면 변동성이 큰 구체적인 객체는 특별히 주의해서 생성해야 한다. 자바 등 대다수의 객체지향 언어에서 이처럼 바람직하지 못한 의존성을 처리할 때 추상 팩토리를 사용하곤 한다. 이는 구체적인 것들로부터 추상적인 것들을 분리하며, 소스코드 의존성은 구체적인 것들에서 추상적인 것들로 향하게 된다.  
추상 컴포넌트는 애플리케이션의 모든 고수준 업무 규칙을 포함하며, 구체 컴포넌트는 업무 규칙을 다루기 위해 필요한 모든 세부 사항을 포함한다.  
제어흐름은 소스코드 의존성과는 정반대 방향으로 흐른다는 점을 주목하자. 다시 말해 소스코드 의존성은 제어흐름과는 반대 방향으로 역전된다. 이러한 이유로 이 원칙을 **의존성 역전(Dependency Inversion)** 이라고 부른다.

### 구체 컴포넌트
DIP 위배를 모두 없앨 수는 없지만, DIP를 위배하는 클래스들은 적은 수의 구체 컴포넌트 내부로 모을 수 있고, 이를 통해 시스템의 나머지 부분과는 분리할 수 있다.

### 결론
추상 컴포넌트와 구체 컴포넌트의 경계는 이후의 장에서는 아키텍처 경계가 될 것이고, 의존성은 더 추상적인 엔티티가 있는 쪽으로만 향한다. 추후 이 규칙은 의존성 규칙이라 부를 것이다.



